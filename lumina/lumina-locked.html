<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="theme-color" content="#1a1a1a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Lumina - Recorded</title>
    <style>
/* ============================================
   DESIGN TOKENS
   ============================================ */
:root {
    /* Colors */
    --bg-primary: #1a1a1a;
    --bg-secondary: #242424;
    --bg-tertiary: #2a2a2a;
    --text-primary: #f5f5f5;
    --text-secondary: #888;
    --text-muted: #666;
    
    /* Borders */
    --border-subtle: rgba(255,255,255,0.06);
    --border-light: rgba(255,255,255,0.08);
    --border-medium: rgba(255,255,255,0.1);
    --border-strong: rgba(255,255,255,0.15);
    
    /* Accents */
    --accent-gold: #E8B84A;
    --accent-verified: #F5F5F5;
    
    /* Shadows */
    --shadow-card: 0 2px 8px rgba(0,0,0,0.3), 0 8px 24px rgba(0,0,0,0.4), 0 24px 48px rgba(0,0,0,0.3);
    
    /* Radii */
    --radius-sm: 8px;
    --radius-md: 10px;
    --radius-lg: 12px;
    
    /* Sizing */
    --touch-target: 44px;
    
    /* Transitions */
    --transition-fast: 0.15s ease;
    --transition-medium: 0.2s ease;
}

/* ============================================
   RESET & BASE
   ============================================ */
* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
    min-height: 100%;
    min-height: -webkit-fill-available;
    background: var(--bg-primary);
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', system-ui, sans-serif;
    color: var(--text-primary);
    -webkit-tap-highlight-color: transparent;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

@media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* ============================================
   HEADER
   ============================================ */
.header {
    position: sticky;
    top: 0;
    height: 56px;
    padding: 0 16px;
    padding-top: env(safe-area-inset-top);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 300;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border-subtle);
}

.header-btn {
    position: absolute;
    width: var(--touch-target);
    height: var(--touch-target);
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: transparent;
    cursor: pointer;
    border-radius: 50%;
    transition: background var(--transition-fast);
}

.header-btn:hover,
.header-btn:focus-visible { background: rgba(255,255,255,0.08); }
.header-btn:focus-visible { outline: 2px solid var(--accent-gold); outline-offset: 2px; }
.header-btn svg { width: 22px; height: 22px; color: var(--text-primary); }

.back-btn { left: 8px; }
.share-btn { right: 8px; }

/* Lumina Logo */
.logo-container {
    display: flex;
    align-items: center;
    gap: 8px;
}

.logo-icon {
    width: 28px;
    height: 28px;
}

.logo-wordmark {
    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    font-size: 20px;
    font-weight: 700;
    letter-spacing: 0.08em;
    background: linear-gradient(135deg, #FFD000 0%, #FFA500 50%, #FFD000 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-transform: uppercase;
}

/* ============================================
   LAYOUT
   ============================================ */
.main-container {
    max-width: 960px;
    margin: 0 auto;
    padding: 24px 16px 48px;
    padding-bottom: calc(48px + env(safe-area-inset-bottom));
    display: flex;
    flex-direction: column;
    gap: 24px;
}

@media (min-width: 768px) {
    .main-container {
        flex-direction: row;
        align-items: flex-start;
        gap: 32px;
        padding: 32px 24px 48px;
    }
}

/* ============================================
   CARD VIEWER
   ============================================ */
.card-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    position: relative;
}

/* Ambient glow effect behind the card - gold tint for recorded state */
.card-section::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -45%);
    width: 400px;
    height: 500px;
    background: radial-gradient(
        ellipse at center,
        rgba(232, 184, 74, 0.12) 0%,
        rgba(232, 184, 74, 0.06) 30%,
        rgba(232, 184, 74, 0.02) 50%,
        transparent 70%
    );
    pointer-events: none;
    z-index: -1;
}

@media (min-width: 768px) {
    .card-section {
        position: sticky;
        top: 80px;
    }
}

.card-wrapper {
    position: relative;
    width: min(260px, 65vw);
    aspect-ratio: 1340 / 1864;
    border-radius: var(--radius-lg);
    overflow: hidden;
    touch-action: none;
    box-shadow: 
        /* Tight gold glow */
        0 0 30px 5px rgba(232, 184, 74, 0.35),
        /* Medium spread */
        0 0 60px 20px rgba(232, 184, 74, 0.2),
        /* Wide atmospheric glow */
        0 0 120px 40px rgba(232, 184, 74, 0.1),
        /* Very wide subtle halo */
        0 0 200px 60px rgba(232, 184, 74, 0.05),
        /* Shadow for depth */
        0 8px 32px rgba(0,0,0,0.5);
    background: var(--bg-tertiary);
    -webkit-user-select: none;
    user-select: none;
}

@media (min-width: 768px) {
    .card-wrapper { width: 280px; }
}

.card-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    transform-origin: center center;
    will-change: transform;
}

.card-canvas.animating {
    transition: transform 0.1s ease-out;
}

.card-layer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    pointer-events: none;
    -webkit-user-drag: none;
    will-change: opacity;
}

.layer-base { 
    z-index: 1; 
    filter: brightness(1.08) contrast(1.05) saturate(1.1);
}
.layer-north { z-index: 2; opacity: 0; filter: brightness(1.08) contrast(1.05) saturate(1.1); }
.layer-south { z-index: 3; opacity: 0; filter: brightness(1.08) contrast(1.05) saturate(1.1); }
.layer-east { z-index: 4; opacity: 0; filter: brightness(1.08) contrast(1.05) saturate(1.1); }
.layer-west { z-index: 5; opacity: 0; filter: brightness(1.08) contrast(1.05) saturate(1.1); }

.card-placeholder {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
    color: var(--text-muted);
    z-index: 0;
}

.card-placeholder svg { width: 48px; height: 48px; opacity: 0.5; }
.card-placeholder span { font-size: 13px; }

/* Recorded Seal Badge */
.recorded-seal {
    position: absolute;
    top: 8px; left: 8px;
    width: 32px; height: 32px;
    z-index: 20;
    opacity: 0.85;
    pointer-events: none;
}

.recorded-seal svg { width: 100%; height: 100%; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4)); }

.card-controls {
    display: flex;
    gap: 8px;
}

.card-control-btn {
    width: var(--touch-target);
    height: var(--touch-target);
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: var(--bg-secondary);
    cursor: pointer;
    border-radius: var(--radius-md);
    border: 1px solid var(--border-light);
    transition: background var(--transition-fast);
}

.card-control-btn:hover,
.card-control-btn:focus-visible { background: var(--bg-tertiary); }
.card-control-btn:focus-visible { outline: 2px solid var(--accent-gold); outline-offset: 2px; }
.card-control-btn svg { width: 18px; height: 18px; color: var(--text-secondary); }
.card-control-btn:hover svg { color: var(--text-primary); }

.zoom-hint {
    font-size: 12px;
    color: var(--text-muted);
    text-align: center;
    display: none;
}

@media (max-width: 767px) and (hover: none) {
    .zoom-hint { display: block; }
}

/* ============================================
   DETAILS SECTION
   ============================================ */
.details-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 16px;
    min-width: 0;
}

/* Verification Card - gold theme for recorded state */
.verification-card {
    background: linear-gradient(135deg, rgba(232, 184, 74, 0.08) 0%, rgba(232, 184, 74, 0.02) 100%);
    border: 1px solid rgba(232, 184, 74, 0.2);
    border-radius: var(--radius-lg);
    padding: 20px;
}

.verification-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
}

.verification-icon {
    width: 44px;
    height: 44px;
    background: rgba(232, 184, 74, 0.15);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}

.verification-icon svg {
    width: 24px;
    height: 24px;
    color: var(--accent-gold);
}

.verification-title {
    font-size: 16px;
    font-weight: 600;
    color: var(--accent-gold);
}

.verification-subtitle {
    font-size: 13px;
    color: var(--text-secondary);
    margin-top: 2px;
}

.timestamp-display {
    background: rgba(0,0,0,0.3);
    border-radius: var(--radius-sm);
    padding: 12px 16px;
    display: flex;
    align-items: center;
    gap: 10px;
}

.timestamp-display svg {
    width: 18px;
    height: 18px;
    color: var(--accent-gold);
    flex-shrink: 0;
}

.timestamp-text {
    font-size: 14px;
    color: var(--text-primary);
}

.timestamp-label {
    font-size: 12px;
    color: var(--text-secondary);
    display: block;
    margin-bottom: 2px;
}

/* Info Cards */
.info-card {
    background: var(--bg-secondary);
    border-radius: var(--radius-lg);
    padding: 20px;
    border: 1px solid var(--border-light);
}

.info-card.hidden { display: none; }

.info-card-title {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 12px;
}

.card-title {
    font-size: 22px;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 4px;
    word-break: break-word;
}

.card-subtitle {
    font-size: 14px;
    color: var(--text-secondary);
}

.info-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 0;
    border-top: 1px solid var(--border-subtle);
    gap: 16px;
}

.info-row:first-of-type { margin-top: 16px; }
.info-row.hidden { display: none; }

.info-label {
    font-size: 13px;
    color: var(--text-muted);
    flex-shrink: 0;
}

.info-value {
    font-size: 13px;
    color: var(--text-primary);
    font-weight: 500;
    text-align: right;
    word-break: break-word;
}

.grade-badge {
    display: inline-flex;
    padding: 4px 10px;
    background: rgba(232, 184, 74, 0.15);
    border: 1px solid rgba(232, 184, 74, 0.3);
    border-radius: 6px;
    font-size: 12px;
    font-weight: 600;
    color: var(--accent-gold);
}

/* Notes Card */
.notes-card {
    background: var(--bg-secondary);
    border-radius: var(--radius-lg);
    padding: 20px;
    border: 1px solid var(--border-light);
}

.notes-card.hidden { display: none; }

.notes-title {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 10px;
}

.notes-text {
    font-size: 14px;
    color: #ccc;
    line-height: 1.6;
    white-space: pre-wrap;
    word-break: break-word;
}

/* Links Card */
.links-card {
    background: var(--bg-secondary);
    border-radius: var(--radius-lg);
    padding: 20px;
    border: 1px solid var(--border-light);
}

.links-card.hidden { display: none; }

.links-title {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 12px;
}

.links-grid {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.link-btn {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px 16px;
    min-height: var(--touch-target);
    background: var(--bg-primary);
    border: 1px solid var(--border-medium);
    border-radius: var(--radius-md);
    text-decoration: none;
    color: var(--text-primary);
    font-size: 14px;
    font-weight: 500;
    transition: all var(--transition-fast);
}

.link-btn:hover,
.link-btn:focus-visible {
    background: #222;
    border-color: rgba(255,255,255,0.2);
}

.link-btn:focus-visible { outline: 2px solid var(--accent-gold); outline-offset: 2px; }
.link-btn.hidden { display: none; }
.link-btn svg { width: 20px; height: 20px; color: var(--text-secondary); flex-shrink: 0; }
.link-btn span { flex: 1; }
.link-btn .link-arrow { width: 16px; height: 16px; color: var(--text-muted); }

/* ============================================
   OVERLAYS & INDICATORS
   ============================================ */
.light-glow {
    position: fixed;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255,220,150,0.12) 0%, transparent 70%);
    pointer-events: none;
    z-index: 100;
    transform: translate(-50%, -50%);
    opacity: 0;
    transition: opacity var(--transition-fast);
}

.light-glow.visible { opacity: 1; }

.zoom-pill {
    position: fixed;
    top: 70px;
    left: 50%;
    transform: translateX(-50%);
    padding: 6px 12px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-medium);
    border-radius: 16px;
    font-size: 12px;
    font-weight: 600;
    color: var(--text-primary);
    z-index: 200;
    opacity: 0;
    pointer-events: none;
    transition: opacity var(--transition-medium);
}

.zoom-pill.visible { opacity: 1; }

.toast {
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%) translateY(20px);
    padding: 12px 20px;
    background: #333;
    border-radius: var(--radius-lg);
    font-size: 14px;
    font-weight: 500;
    color: #fff;
    opacity: 0;
    pointer-events: none;
    transition: all 0.3s ease;
    z-index: 400;
}

.toast.visible {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
}

/* ============================================
   MODE TOGGLE (Pan/Light)
   ============================================ */
.mode-toggle-container {
    display: flex;
    justify-content: center;
    margin-top: 8px;
}

.mode-toggle {
    display: flex;
    background: var(--bg-secondary);
    border: 1px solid var(--border-light);
    border-radius: 20px;
    padding: 4px;
    gap: 4px;
}

.mode-toggle-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 8px 14px;
    min-height: 36px;
    background: transparent;
    border: none;
    border-radius: 16px;
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all var(--transition-fast);
}

.mode-toggle-btn:hover {
    color: var(--text-primary);
    background: rgba(255,255,255,0.05);
}

.mode-toggle-btn:focus-visible {
    outline: 2px solid var(--accent-gold);
    outline-offset: 2px;
}

.mode-toggle-btn.active {
    background: var(--accent-gold);
    color: var(--bg-primary);
}

.mode-toggle-btn svg {
    width: 16px;
    height: 16px;
}

.mode-toggle-btn.active svg {
    color: var(--bg-primary);
}

/* Fullscreen mode toggle */
.fs-mode-toggle-container {
    display: flex;
    justify-content: center;
    margin-bottom: 8px;
}

.fs-mode-toggle {
    display: flex;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 20px;
    padding: 4px;
    gap: 4px;
}

.fs-mode-toggle .mode-toggle-btn {
    color: var(--text-secondary);
}

.fs-mode-toggle .mode-toggle-btn:hover {
    color: var(--text-primary);
    background: rgba(255,255,255,0.1);
}

.fs-mode-toggle .mode-toggle-btn.active {
    background: var(--accent-gold);
    color: var(--bg-primary);
}

/* ============================================
   TEXTURE TOGGLE
   ============================================ */
.texture-layer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    pointer-events: none;
    z-index: 10;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.texture-layer.visible {
    opacity: 1;
}

/* Forensic canvas overlay */
.forensic-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 10;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.forensic-canvas.visible {
    opacity: 1;
}

.texture-toggle-btn {
    position: absolute;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    height: 36px;
    padding: 0 16px;
    background: rgba(0,0,0,0.7);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 18px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    z-index: 25;
    opacity: 1;
    transition: background var(--transition-fast), border-color var(--transition-fast);
}

.texture-toggle-btn:hover { background: rgba(0,0,0,0.85); border-color: rgba(255,255,255,0.25); }
.texture-toggle-btn:focus-visible { outline: 2px solid var(--accent-gold); outline-offset: 2px; }

.texture-toggle-btn.active {
    background: rgba(232, 184, 74, 0.2);
    border-color: var(--accent-gold);
}

.texture-toggle-btn svg {
    width: 16px;
    height: 16px;
    color: var(--text-secondary);
    transition: color var(--transition-fast);
}

.texture-toggle-btn.active svg { color: var(--accent-gold); }

.texture-toggle-label {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-secondary);
    transition: color var(--transition-fast);
}

.texture-toggle-btn.active .texture-toggle-label { color: var(--accent-gold); }

/* Fullscreen texture toggle */
.fullscreen-texture-toggle { display: flex; justify-content: center; }

.fs-texture-toggle-btn {
    height: 40px;
    padding: 0 20px;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    transition: all var(--transition-fast);
}

.fs-texture-toggle-btn:hover { background: rgba(255,255,255,0.2); }
.fs-texture-toggle-btn:focus-visible { outline: 2px solid var(--accent-gold); outline-offset: 2px; }

.fs-texture-toggle-btn.active {
    background: rgba(232, 184, 74, 0.2);
    border-color: var(--accent-gold);
}

.fs-texture-toggle-btn svg {
    width: 18px;
    height: 18px;
    color: var(--text-secondary);
    transition: color var(--transition-fast);
}

.fs-texture-toggle-btn.active svg { color: var(--accent-gold); }
.fs-texture-toggle-btn .texture-toggle-label { font-size: 12px; }
.fs-texture-toggle-btn.active .texture-toggle-label { color: var(--accent-gold); }

/* Fullscreen card layer brightness boost */
#fullscreen-card-canvas .layer-base,
#fullscreen-card-canvas .layer-north,
#fullscreen-card-canvas .layer-south,
#fullscreen-card-canvas .layer-east,
#fullscreen-card-canvas .layer-west {
    filter: brightness(1.08) contrast(1.05) saturate(1.1);
}

/* Fullscreen button */
.fullscreen-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 36px;
    height: 36px;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: var(--radius-sm);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 25;
    opacity: 0;
    transition: opacity var(--transition-medium), background var(--transition-fast);
}

.card-wrapper:hover .fullscreen-btn { opacity: 1; }
@media (hover: none) { .fullscreen-btn { opacity: 1; } }

.fullscreen-btn:hover { background: rgba(0,0,0,0.8); }
.fullscreen-btn:focus-visible { outline: 2px solid var(--accent-gold); outline-offset: 2px; }
.fullscreen-btn svg { width: 18px; height: 18px; color: var(--text-primary); }

/* Fullscreen overlay */
.fullscreen-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: #000;
    z-index: 1000;
    flex-direction: column;
}

.fullscreen-overlay.active { display: flex; }

.fullscreen-header {
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 56px;
    padding: 0 16px;
    padding-top: env(safe-area-inset-top);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, transparent 100%);
    z-index: 1010;
}

.fullscreen-title {
    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    font-size: 16px;
    font-weight: 700;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    background: linear-gradient(135deg, #FFD000 0%, #FFA500 50%, #FFD000 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.fullscreen-close {
    width: var(--touch-target);
    height: var(--touch-target);
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.1);
    border: none;
    border-radius: 50%;
    cursor: pointer;
    transition: background var(--transition-fast);
}

.fullscreen-close:hover { background: rgba(255,255,255,0.2); }
.fullscreen-close:focus-visible { outline: 2px solid var(--accent-gold); outline-offset: 2px; }
.fullscreen-close svg { width: 24px; height: 24px; color: var(--text-primary); }

.fullscreen-card-area {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 60px 16px 100px;
    overflow: hidden;
    background: radial-gradient(
        ellipse at center,
        rgba(232, 184, 74, 0.08) 0%,
        rgba(232, 184, 74, 0.04) 25%,
        rgba(0, 0, 0, 0) 50%,
        rgba(0, 0, 0, 0.3) 100%
    );
}

.fullscreen-card-wrapper {
    position: relative;
    width: 100%;
    max-width: min(90vw, 600px);
    max-height: 100%;
    aspect-ratio: 1340 / 1864;
    border-radius: var(--radius-lg);
    overflow: hidden;
    touch-action: none;
    box-shadow: 
        0 0 40px 10px rgba(232, 184, 74, 0.3),
        0 0 80px 30px rgba(232, 184, 74, 0.15),
        0 0 160px 60px rgba(232, 184, 74, 0.08),
        0 0 280px 100px rgba(232, 184, 74, 0.04),
        0 12px 48px rgba(0,0,0,0.6);
    -webkit-user-select: none;
    user-select: none;
}

@media (orientation: landscape) {
    .fullscreen-card-wrapper {
        max-width: none;
        width: auto;
        height: 100%;
        max-height: calc(100vh - 160px);
    }
}

.fullscreen-controls {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    padding: 16px;
    padding-bottom: calc(16px + env(safe-area-inset-bottom));
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 100%);
    display: flex;
    flex-direction: column;
    gap: 12px;
    z-index: 1010;
}

.fullscreen-zoom-controls {
    display: flex;
    justify-content: center;
    gap: 12px;
}

.fullscreen-zoom-btn {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: var(--radius-md);
    cursor: pointer;
    transition: background var(--transition-fast);
}

.fullscreen-zoom-btn:hover { background: rgba(255,255,255,0.2); }
.fullscreen-zoom-btn svg { width: 22px; height: 22px; color: var(--text-primary); }

.fullscreen-zoom-level {
    min-width: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
}

body.fullscreen-active {
    overflow: hidden;
    position: fixed;
    width: 100%;
    height: 100%;
}
    </style>
</head>
<body>
    <!-- ============================================
         HEADER
         ============================================ -->
    <header class="header">
        <button class="header-btn back-btn" id="back-btn" aria-label="Go back">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
        </button>
        <div class="logo-container">
            <svg class="logo-icon" viewBox="0 0 100 100" fill="none" aria-hidden="true">
                <!-- Glow rect -->
                <rect x="26" y="20" width="48" height="60" rx="6" fill="#FFD000" fill-opacity="0.15"/>
                <!-- Main card -->
                <rect x="30" y="24" width="40" height="52" rx="4" fill="#FFD000"/>
                <!-- Corner brackets -->
                <g stroke="#FFD000" stroke-width="4" stroke-linecap="round" stroke-opacity="0.5">
                    <!-- Top-left -->
                    <path d="M12 30 L12 12 L30 12"/>
                    <!-- Top-right -->
                    <path d="M88 30 L88 12 L70 12"/>
                    <!-- Bottom-left -->
                    <path d="M12 70 L12 88 L30 88"/>
                    <!-- Bottom-right -->
                    <path d="M88 70 L88 88 L70 88"/>
                </g>
            </svg>
            <span class="logo-wordmark">Lumina</span>
        </div>
        <button class="header-btn share-btn" id="share-btn" aria-label="Share">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <circle cx="18" cy="5" r="3"/>
                <circle cx="6" cy="12" r="3"/>
                <circle cx="18" cy="19" r="3"/>
                <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
            </svg>
        </button>
    </header>

    <!-- ============================================
         MAIN CONTENT
         ============================================ -->
    <main class="main-container">
        <!-- Card Preview Section -->
        <section class="card-section" aria-label="Card preview">
            <div class="card-wrapper" id="card-wrapper" role="img" aria-label="Interactive card preview - drag to change lighting, pinch to zoom, slide to reveal texture">
                <div class="card-canvas" id="card-canvas">
                    <div class="card-placeholder" id="card-placeholder">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <path d="M21 15l-5-5L5 21"/>
                        </svg>
                        <span>Card preview</span>
                    </div>
                    <img class="card-layer layer-base" id="layer-base" alt="" src="" loading="eager">
                    <img class="card-layer layer-north" id="layer-north" alt="" src="" loading="eager">
                    <img class="card-layer layer-south" id="layer-south" alt="" src="" loading="eager">
                    <img class="card-layer layer-east" id="layer-east" alt="" src="" loading="eager">
                    <img class="card-layer layer-west" id="layer-west" alt="" src="" loading="eager">
                    <!-- Forensic Relief Map Canvas -->
                    <canvas class="forensic-canvas" id="forensic-canvas"></canvas>
                </div>
                <!-- Recorded Seal Badge -->
                <div class="recorded-seal" aria-hidden="true">
                    <svg viewBox="0 0 32 32" fill="none">
                        <circle cx="16" cy="16" r="14" fill="rgba(232, 184, 74, 0.15)" stroke="#E8B84A" stroke-width="1.5"/>
                        <path d="M10 16.5L14 20.5L22 12.5" stroke="#E8B84A" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
                <button class="fullscreen-btn" id="fullscreen-btn" aria-label="Enter fullscreen mode">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                    </svg>
                </button>
                <!-- Forensic Toggle Button -->
                <button class="texture-toggle-btn" id="texture-toggle-btn" aria-label="Toggle forensic texture view" aria-pressed="false">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                    </svg>
                    <span class="texture-toggle-label">Forensic</span>
                </button>
            </div>
            <div class="card-controls">
                <button class="card-control-btn" id="zoom-out-btn" aria-label="Zoom out">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
                <button class="card-control-btn" id="zoom-in-btn" aria-label="Zoom in">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
            </div>
            <!-- Mode Toggle (Pan/Light) -->
            <div class="mode-toggle-container">
                <div class="mode-toggle" role="radiogroup" aria-label="Interaction mode">
                    <button class="mode-toggle-btn active" id="mode-pan-btn" role="radio" aria-checked="true" aria-label="Pan mode">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/>
                        </svg>
                        Pan
                    </button>
                    <button class="mode-toggle-btn" id="mode-light-btn" role="radio" aria-checked="false" aria-label="Light mode">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                        </svg>
                        Light
                    </button>
                </div>
            </div>
            <p class="zoom-hint">Pinch to zoom &bull; Double-tap to toggle</p>
        </section>

        <!-- Details Section -->
        <section class="details-section" aria-label="Card verification details">
            <!-- Verification Status -->
            <div class="verification-card">
                <div class="verification-header">
                    <div class="verification-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                            <polyline points="22 4 12 14.01 9 11.01"/>
                        </svg>
                    </div>
                    <div>
                        <div class="verification-title">Digital Twin â€” Recorded</div>
                        <div class="verification-subtitle">Permanently documented</div>
                    </div>
                </div>
                <div class="timestamp-display">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                    </svg>
                    <div>
                        <span class="timestamp-label">Recorded on</span>
                        <span class="timestamp-text" id="display-timestamp">--</span>
                    </div>
                </div>
            </div>

            <!-- Card Information -->
            <div class="info-card" id="info-card">
                <div class="info-card-title">Card Details</div>
                <h1 class="card-title" id="display-name">--</h1>
                <p class="card-subtitle" id="display-set">--</p>
                
                <div class="info-row" id="row-number">
                    <span class="info-label">Number</span>
                    <span class="info-value" id="display-number">--</span>
                </div>
                <div class="info-row" id="row-language">
                    <span class="info-label">Language</span>
                    <span class="info-value" id="display-language">--</span>
                </div>
                <div class="info-row" id="row-edition">
                    <span class="info-label">Edition</span>
                    <span class="info-value" id="display-edition">--</span>
                </div>
                <div class="info-row" id="row-grade">
                    <span class="info-label">Grade</span>
                    <span class="info-value"><span class="grade-badge" id="display-grade">--</span></span>
                </div>
            </div>

            <!-- Condition Notes -->
            <div class="notes-card hidden" id="notes-card">
                <div class="notes-title">Condition Notes</div>
                <p class="notes-text" id="display-notes"></p>
            </div>

            <!-- Marketplace Links -->
            <div class="links-card hidden" id="links-card">
                <div class="links-title">Marketplace Links</div>
                <div class="links-grid">
                    <a href="#" class="link-btn hidden" id="link-ebay" target="_blank" rel="noopener noreferrer">
                        <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                            <rect x="3" y="3" width="18" height="18" rx="3"/>
                        </svg>
                        <span>eBay</span>
                        <svg class="link-arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                            <path d="M7 17L17 7M17 7H7M17 7v10"/>
                        </svg>
                    </a>
                    <a href="#" class="link-btn hidden" id="link-facebook" target="_blank" rel="noopener noreferrer">
                        <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                            <circle cx="12" cy="12" r="10"/>
                        </svg>
                        <span>Facebook Marketplace</span>
                        <svg class="link-arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                            <path d="M7 17L17 7M17 7H7M17 7v10"/>
                        </svg>
                    </a>
                    <a href="#" class="link-btn hidden" id="link-tcgplayer" target="_blank" rel="noopener noreferrer">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                            <rect x="2" y="3" width="20" height="14" rx="2"/>
                        </svg>
                        <span>TCGPlayer</span>
                        <svg class="link-arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                            <path d="M7 17L17 7M17 7H7M17 7v10"/>
                        </svg>
                    </a>
                    <a href="#" class="link-btn hidden" id="link-mercari" target="_blank" rel="noopener noreferrer">
                        <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                            <circle cx="12" cy="12" r="10"/>
                        </svg>
                        <span>Mercari</span>
                        <svg class="link-arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                            <path d="M7 17L17 7M17 7H7M17 7v10"/>
                        </svg>
                    </a>
                    <a href="#" class="link-btn hidden" id="link-other" target="_blank" rel="noopener noreferrer">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="2" y1="12" x2="22" y2="12"/>
                        </svg>
                        <span>Other Link</span>
                        <svg class="link-arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                            <path d="M7 17L17 7M17 7H7M17 7v10"/>
                        </svg>
                    </a>
                </div>
            </div>
    </main>


    <!-- Fullscreen Overlay -->
    <div class="fullscreen-overlay" id="fullscreen-overlay" role="dialog" aria-modal="true" aria-label="Fullscreen card viewer">
        <div class="fullscreen-header">
            <span class="fullscreen-title">Inspect Card</span>
            <button class="fullscreen-close" id="fullscreen-close" aria-label="Exit fullscreen">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>
        </div>
        <div class="fullscreen-card-area" id="fullscreen-card-area">
            <div class="fullscreen-card-wrapper" id="fullscreen-card-wrapper">
                <div class="card-canvas" id="fullscreen-card-canvas">
                    <img class="card-layer layer-base" id="fs-layer-base" alt="" src="" loading="eager">
                    <img class="card-layer layer-north" id="fs-layer-north" alt="" src="" loading="eager">
                    <img class="card-layer layer-south" id="fs-layer-south" alt="" src="" loading="eager">
                    <img class="card-layer layer-east" id="fs-layer-east" alt="" src="" loading="eager">
                    <img class="card-layer layer-west" id="fs-layer-west" alt="" src="" loading="eager">
                    <canvas class="forensic-canvas" id="fs-forensic-canvas"></canvas>
                </div>
            </div>
        </div>
        <div class="fullscreen-controls">
            <!-- Mode Toggle (Pan/Light) for fullscreen -->
            <div class="fs-mode-toggle-container">
                <div class="fs-mode-toggle" role="radiogroup" aria-label="Interaction mode">
                    <button class="mode-toggle-btn active" id="fs-mode-pan-btn" role="radio" aria-checked="true" aria-label="Pan mode">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/>
                        </svg>
                        Pan
                    </button>
                    <button class="mode-toggle-btn" id="fs-mode-light-btn" role="radio" aria-checked="false" aria-label="Light mode">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                        </svg>
                        Light
                    </button>
                </div>
            </div>
            <div class="fullscreen-texture-toggle">
                <button class="fs-texture-toggle-btn" id="fs-texture-toggle-btn" aria-label="Toggle forensic texture view" aria-pressed="false">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                    </svg>
                    <span class="texture-toggle-label">Forensic</span>
                </button>
            </div>
            <div class="fullscreen-zoom-controls">
                <button class="fullscreen-zoom-btn" id="fs-zoom-out" aria-label="Zoom out">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
                <span class="fullscreen-zoom-level" id="fs-zoom-level">1.0x</span>
                <button class="fullscreen-zoom-btn" id="fs-zoom-in" aria-label="Zoom in">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Overlays -->
    <div class="light-glow" id="light-glow" aria-hidden="true"></div>
    <div class="zoom-pill" id="zoom-pill" aria-live="polite">1.0x</div>
    <div class="toast" id="toast">Link copied to clipboard</div>

    <!-- ============================================
         JAVASCRIPT
         ============================================ -->
    <script>
/**
 * Lumina Locked Controller
 * Read-only verification display
 */
const Lumina = (function() {
    'use strict';

    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
        minZoom: 1,
        maxZoom: 5,
        doubleTapDelay: 300,
        doubleTapDistance: 30
    };

    // Language and edition maps
    const LANGUAGE_MAP = {
        'EN': 'English', 'JP': 'Japanese', 'KR': 'Korean', 'ZH': 'Chinese',
        'DE': 'German', 'FR': 'French', 'IT': 'Italian', 'ES': 'Spanish', 'PT': 'Portuguese'
    };

    const EDITION_MAP = {
        'UNL': 'Unlimited', '1ST': '1st Edition', 'SHD': 'Shadowless', 'PRO': 'Promo'
    };

    const GRADE_MAP = {
        'M': 'Mint', 'NM': 'Near Mint', 'LP': 'Lightly Played',
        'MP': 'Moderately Played', 'HP': 'Heavily Played', 'DMG': 'Damaged'
    };

    // ============================================
    // STATE
    // ============================================
    const state = {
        zoom: 1,
        panX: 0,
        panY: 0,
        isPanning: false,
        lastX: 0,
        lastY: 0,
        initialPinchDistance: 0,
        initialPinchZoom: 1,
        lastTapTime: 0,
        lastTapX: 0,
        lastTapY: 0,
        textureVisible: false,
        interactionMode: 'pan', // 'pan' or 'light'
        imagesLoaded: false
    };

    // ============================================
    // DOM REFERENCES
    // ============================================
    let elements = {};

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================
    const utils = {
        vibrate(pattern) {
            if (navigator.vibrate) navigator.vibrate(pattern);
        },

        safeLocalStorage(action, key) {
            try {
                if (action === 'get') return localStorage.getItem(key);
            } catch (e) {
                console.error('localStorage error:', e);
                return null;
            }
        }
    };

    // ============================================
    // CARD VIEWER MODULE
    // ============================================
    const cardViewer = {
        layers: {},

        init() {
            this.layers = {
                north: document.getElementById('layer-north'),
                south: document.getElementById('layer-south'),
                east: document.getElementById('layer-east'),
                west: document.getElementById('layer-west')
            };
        },

        setZoom(newZoom, centerX = null, centerY = null, animate = false) {
            const oldZoom = state.zoom;
            state.zoom = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, newZoom));
            
            if (centerX !== null && centerY !== null && state.zoom !== oldZoom) {
                const rect = elements.cardWrapper.getBoundingClientRect();
                const relX = (centerX - rect.left) / rect.width - 0.5;
                const relY = (centerY - rect.top) / rect.height - 0.5;
                const zoomDelta = state.zoom - oldZoom;
                state.panX -= relX * zoomDelta * 100;
                state.panY -= relY * zoomDelta * 100;
            }
            
            if (state.zoom === 1) { state.panX = 0; state.panY = 0; }
            this.constrainPan();
            
            if (animate) {
                elements.cardCanvas.classList.add('animating');
                setTimeout(() => elements.cardCanvas.classList.remove('animating'), 300);
            }
            
            this.applyTransform();
            this.updateZoomPill();
        },

        constrainPan() {
            if (state.zoom <= 1) { state.panX = 0; state.panY = 0; return; }
            const maxPan = (state.zoom - 1) * 50;
            state.panX = Math.max(-maxPan, Math.min(maxPan, state.panX));
            state.panY = Math.max(-maxPan, Math.min(maxPan, state.panY));
        },

        applyTransform() {
            elements.cardCanvas.style.transform = `scale(${state.zoom}) translate(${state.panX / state.zoom}%, ${state.panY / state.zoom}%)`;
        },

        updateZoomPill() {
            elements.zoomPill.textContent = `${state.zoom.toFixed(1)}x`;
            elements.zoomPill.classList.toggle('visible', state.zoom > 1);
        },

        updateLight(x, y) {
            const rect = elements.cardWrapper.getBoundingClientRect();
            const px = Math.max(0, Math.min(1, (x - rect.left) / rect.width));
            const py = Math.max(0, Math.min(1, (y - rect.top) / rect.height));

            elements.lightGlow.style.left = x + 'px';
            elements.lightGlow.style.top = y + 'px';
            elements.lightGlow.classList.add('visible');

            const dx = (px - 0.5) * 2;
            const dy = (py - 0.5) * 2;

            this.layers.north.style.opacity = Math.min(1, Math.max(0, -dy) * 1.4);
            this.layers.south.style.opacity = Math.min(1, Math.max(0, dy) * 1.4);
            this.layers.east.style.opacity = Math.min(1, Math.max(0, dx) * 1.4);
            this.layers.west.style.opacity = Math.min(1, Math.max(0, -dx) * 1.4);
        },

        resetLight() {
            elements.lightGlow.classList.remove('visible');
            Object.values(this.layers).forEach(l => l.style.opacity = 0);
        },

        getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        },

        getPinchCenter(touches) {
            return {
                x: (touches[0].clientX + touches[1].clientX) / 2,
                y: (touches[0].clientY + touches[1].clientY) / 2
            };
        },

        loadImages(imageData) {
            const layers = ['base', 'north', 'south', 'east', 'west'];
            let loadedCount = 0;

            layers.forEach(layer => {
                const img = document.getElementById(`layer-${layer}`);
                if (imageData[layer]) {
                    img.onload = () => {
                        loadedCount++;
                        if (loadedCount === layers.length) {
                            document.getElementById('card-placeholder').style.display = 'none';
                            state.imagesLoaded = true;
                            // Notify forensic analysis that images are ready
                            if (typeof forensicAnalysis !== 'undefined') {
                                forensicAnalysis.onImagesLoaded();
                            }
                        }
                    };
                    img.src = imageData[layer];
                }
            });
        }
    };

    // ============================================
    // FORENSIC ANALYSIS MODULE (Photometric Stereo)
    // ============================================
    const forensicAnalysis = {
        computed: false,
        mainCanvas: null,
        fsCanvas: null,
        
        init() {
            const mainBtn = document.getElementById('texture-toggle-btn');
            const fsBtn = document.getElementById('fs-texture-toggle-btn');
            
            this.mainCanvas = document.getElementById('forensic-canvas');
            this.fsCanvas = document.getElementById('fs-forensic-canvas');
            
            if (mainBtn) {
                mainBtn.addEventListener('click', () => this.toggle());
            }
            if (fsBtn) {
                fsBtn.addEventListener('click', () => this.toggle());
            }
        },

        toggle() {
            // Compute relief map on first toggle if not already done
            if (!this.computed && state.imagesLoaded) {
                this.computeReliefMap();
            }
            
            state.textureVisible = !state.textureVisible;
            this.updateUI();
            utils.vibrate(10);
        },

        updateUI() {
            // Update main view
            const mainBtn = document.getElementById('texture-toggle-btn');
            
            if (mainBtn) {
                mainBtn.classList.toggle('active', state.textureVisible);
                mainBtn.setAttribute('aria-pressed', state.textureVisible);
            }
            if (this.mainCanvas) {
                this.mainCanvas.classList.toggle('visible', state.textureVisible);
            }
            
            // Update fullscreen view
            const fsBtn = document.getElementById('fs-texture-toggle-btn');
            
            if (fsBtn) {
                fsBtn.classList.toggle('active', state.textureVisible);
                fsBtn.setAttribute('aria-pressed', state.textureVisible);
            }
            if (this.fsCanvas) {
                this.fsCanvas.classList.toggle('visible', state.textureVisible);
            }
        },

        computeReliefMap() {
            // Get the directional images
            const northImg = document.getElementById('layer-north');
            const southImg = document.getElementById('layer-south');
            const eastImg = document.getElementById('layer-east');
            const westImg = document.getElementById('layer-west');
            
            if (!northImg.complete || !southImg.complete || !eastImg.complete || !westImg.complete) {
                console.log('Images not loaded yet');
                return;
            }
            
            const width = northImg.naturalWidth;
            const height = northImg.naturalHeight;
            
            if (width === 0 || height === 0) {
                console.log('Invalid image dimensions');
                return;
            }
            
            console.log(`Computing relief map: ${width}x${height}`);
            
            // Create temporary canvas to read pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            
            // Get pixel data from each directional image
            const getImageData = (img) => {
                tempCtx.clearRect(0, 0, width, height);
                tempCtx.drawImage(img, 0, 0);
                return tempCtx.getImageData(0, 0, width, height).data;
            };
            
            const northData = getImageData(northImg);
            const southData = getImageData(southImg);
            const eastData = getImageData(eastImg);
            const westData = getImageData(westImg);
            
            // Setup main forensic canvas
            this.mainCanvas.width = width;
            this.mainCanvas.height = height;
            const mainCtx = this.mainCanvas.getContext('2d');
            const outputData = mainCtx.createImageData(width, height);
            
            // Photometric stereo: compute surface gradients from directional lighting
            // dz/dx â‰ˆ (East - West) / 2
            // dz/dy â‰ˆ (North - South) / 2  (note: image Y is inverted)
            
            for (let i = 0; i < northData.length; i += 4) {
                // Get luminance from each direction
                const lNorth = (northData[i] * 0.299 + northData[i+1] * 0.587 + northData[i+2] * 0.114);
                const lSouth = (southData[i] * 0.299 + southData[i+1] * 0.587 + southData[i+2] * 0.114);
                const lEast = (eastData[i] * 0.299 + eastData[i+1] * 0.587 + eastData[i+2] * 0.114);
                const lWest = (westData[i] * 0.299 + westData[i+1] * 0.587 + westData[i+2] * 0.114);
                
                // Compute surface gradients (normalized to -1 to 1 range)
                const dx = (lEast - lWest) / 255;  // X gradient
                const dy = (lSouth - lNorth) / 255; // Y gradient (inverted for image coords)
                
                // Compute surface normal from gradients
                // N = normalize(-dx, -dy, 1)
                const mag = Math.sqrt(dx * dx + dy * dy + 1);
                const nx = -dx / mag;
                const ny = -dy / mag;
                const nz = 1 / mag;
                
                // Light from upper-left for dramatic relief effect
                const lightX = -0.5;
                const lightY = -0.5;
                const lightZ = 0.707;
                
                // Diffuse shading
                let diffuse = nx * lightX + ny * lightY + nz * lightZ;
                diffuse = Math.max(0, diffuse);
                
                // Edge detection based on gradient magnitude
                const gradMag = Math.sqrt(dx * dx + dy * dy);
                const edge = Math.min(1, gradMag * 3);
                
                // Amber/gold highlight color for raised areas
                const highlight = Math.pow(diffuse, 0.8);
                
                // Dark background with amber highlights
                // Base: dark gray, Highlights: amber/gold
                const baseR = 20;
                const baseG = 18;
                const baseB = 15;
                
                const highlightR = 255;
                const highlightG = 180;
                const highlightB = 50;
                
                // Mix based on lighting
                const r = Math.round(baseR + (highlightR - baseR) * highlight * 0.9 + edge * 60);
                const g = Math.round(baseG + (highlightG - baseG) * highlight * 0.9 + edge * 40);
                const b = Math.round(baseB + (highlightB - baseB) * highlight * 0.5 + edge * 20);
                
                outputData.data[i] = Math.min(255, r);
                outputData.data[i + 1] = Math.min(255, g);
                outputData.data[i + 2] = Math.min(255, b);
                outputData.data[i + 3] = 255;
            }
            
            mainCtx.putImageData(outputData, 0, 0);
            
            // Copy to fullscreen canvas
            this.fsCanvas.width = width;
            this.fsCanvas.height = height;
            const fsCtx = this.fsCanvas.getContext('2d');
            fsCtx.drawImage(this.mainCanvas, 0, 0);
            
            this.computed = true;
            console.log('Relief map computed');
        },
        
        // Call this when images are loaded
        onImagesLoaded() {
            // Pre-compute if forensic view is already visible
            if (state.textureVisible && !this.computed) {
                this.computeReliefMap();
            }
        }
    };

    // ============================================
    // MODE TOGGLE MODULE (Pan/Light)
    // ============================================
    const modeToggle = {
        init() {
            const panBtn = document.getElementById('mode-pan-btn');
            const lightBtn = document.getElementById('mode-light-btn');
            const fsPanBtn = document.getElementById('fs-mode-pan-btn');
            const fsLightBtn = document.getElementById('fs-mode-light-btn');

            if (panBtn) panBtn.addEventListener('click', () => this.setMode('pan'));
            if (lightBtn) lightBtn.addEventListener('click', () => this.setMode('light'));
            if (fsPanBtn) fsPanBtn.addEventListener('click', () => this.setMode('pan'));
            if (fsLightBtn) fsLightBtn.addEventListener('click', () => this.setMode('light'));
        },

        setMode(mode) {
            state.interactionMode = mode;
            this.updateUI();
            utils.vibrate(10);
        },

        updateUI() {
            const isPan = state.interactionMode === 'pan';

            const panBtn = document.getElementById('mode-pan-btn');
            const lightBtn = document.getElementById('mode-light-btn');
            if (panBtn) {
                panBtn.classList.toggle('active', isPan);
                panBtn.setAttribute('aria-checked', isPan);
            }
            if (lightBtn) {
                lightBtn.classList.toggle('active', !isPan);
                lightBtn.setAttribute('aria-checked', !isPan);
            }

            const fsPanBtn = document.getElementById('fs-mode-pan-btn');
            const fsLightBtn = document.getElementById('fs-mode-light-btn');
            if (fsPanBtn) {
                fsPanBtn.classList.toggle('active', isPan);
                fsPanBtn.setAttribute('aria-checked', isPan);
            }
            if (fsLightBtn) {
                fsLightBtn.classList.toggle('active', !isPan);
                fsLightBtn.setAttribute('aria-checked', !isPan);
            }
        }
    };

    // ============================================
    // FULLSCREEN MODULE
    // ============================================
    const fullscreen = {
        isActive: false,
        previousFocus: null,
        fsState: { zoom: 1, panX: 0, panY: 0 },

        init() {
            this.setupCardInteractions();
        },

        enter() {
            this.isActive = true;
            this.previousFocus = document.activeElement;
            
            document.body.classList.add('fullscreen-active');
            document.getElementById('fullscreen-overlay').classList.add('active');
            
            ['base', 'north', 'south', 'east', 'west'].forEach(layer => {
                const src = document.getElementById(`layer-${layer}`).src;
                document.getElementById(`fs-layer-${layer}`).src = src;
            });
            
            // Sync forensic toggle state
            forensicAnalysis.updateUI();
            this.fsState = { zoom: 1, panX: 0, panY: 0 };
            this.applyTransform();
            this.updateZoomLevel();
            
            document.getElementById('fullscreen-close').focus();
            
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(() => {});
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            }
            
            utils.vibrate(10);
        },

        exit() {
            this.isActive = false;
            document.body.classList.remove('fullscreen-active');
            document.getElementById('fullscreen-overlay').classList.remove('active');
            
            if (document.exitFullscreen) {
                document.exitFullscreen().catch(() => {});
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
            
            if (this.previousFocus) this.previousFocus.focus();
        },

        setupCardInteractions() {
            const wrapper = document.getElementById('fullscreen-card-wrapper');
            const canvas = document.getElementById('fullscreen-card-canvas');
            if (!wrapper || !canvas) return;

            const fsLayers = {
                north: document.getElementById('fs-layer-north'),
                south: document.getElementById('fs-layer-south'),
                east: document.getElementById('fs-layer-east'),
                west: document.getElementById('fs-layer-west')
            };

            let isPanning = false, lastX = 0, lastY = 0;
            let lastTapTime = 0, lastTapX = 0, lastTapY = 0;
            let initialPinchDistance = 0, initialPinchZoom = 1;

            const updateLight = (x, y) => {
                const rect = wrapper.getBoundingClientRect();
                const px = Math.max(0, Math.min(1, (x - rect.left) / rect.width));
                const py = Math.max(0, Math.min(1, (y - rect.top) / rect.height));
                const dx = (px - 0.5) * 2, dy = (py - 0.5) * 2;

                fsLayers.north.style.opacity = Math.min(1, Math.max(0, -dy) * 1.4);
                fsLayers.south.style.opacity = Math.min(1, Math.max(0, dy) * 1.4);
                fsLayers.east.style.opacity = Math.min(1, Math.max(0, dx) * 1.4);
                fsLayers.west.style.opacity = Math.min(1, Math.max(0, -dx) * 1.4);
            };

            const resetLight = () => Object.values(fsLayers).forEach(l => l.style.opacity = 0);

            const getPinchDistance = (touches) => {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            };

            wrapper.addEventListener('touchstart', e => {
                
                
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    const now = Date.now();
                    const dx = touch.clientX - lastTapX, dy = touch.clientY - lastTapY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (now - lastTapTime < CONFIG.doubleTapDelay && distance < CONFIG.doubleTapDistance) {
                        e.preventDefault();
                        this.setZoom(this.fsState.zoom > 1 ? 1 : 3, touch.clientX, touch.clientY, true);
                        utils.vibrate(10);
                        lastTapTime = 0;
                    } else {
                        lastTapTime = now;
                        lastTapX = touch.clientX;
                        lastTapY = touch.clientY;
                        isPanning = true;
                        lastX = touch.clientX;
                        lastY = touch.clientY;
                        updateLight(lastX, lastY);
                    }
                } else if (e.touches.length === 2) {
                    isPanning = false;
                    initialPinchDistance = getPinchDistance(e.touches);
                    initialPinchZoom = this.fsState.zoom;
                }
            }, { passive: false });

            wrapper.addEventListener('touchmove', e => {
                
                e.preventDefault();
                
                if (e.touches.length === 1 && isPanning) {
                    const t = e.touches[0];
                    
                    if (this.fsState.zoom > 1) {
                        if (state.interactionMode === 'pan') {
                            const rect = wrapper.getBoundingClientRect();
                            this.fsState.panX += (t.clientX - lastX) / rect.width * 100;
                            this.fsState.panY += (t.clientY - lastY) / rect.height * 100;
                            this.constrainPan();
                            this.applyTransform();
                        } else {
                            updateLight(t.clientX, t.clientY);
                        }
                    } else {
                        updateLight(t.clientX, t.clientY);
                    }
                    lastX = t.clientX;
                    lastY = t.clientY;
                } else if (e.touches.length === 2) {
                    const currentDistance = getPinchDistance(e.touches);
                    const center = {
                        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                        y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                    };
                    this.setZoom(initialPinchZoom * (currentDistance / initialPinchDistance), center.x, center.y);
                }
            }, { passive: false });

            wrapper.addEventListener('touchend', e => {
                if (e.touches.length === 0) { isPanning = false; resetLight(); }
                else if (e.touches.length === 1) { lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; isPanning = true; }
            }, { passive: true });

            let lastClickTime = 0;
            wrapper.addEventListener('mousedown', e => {
                
                const now = Date.now();
                if (now - lastClickTime < CONFIG.doubleTapDelay) {
                    this.setZoom(this.fsState.zoom > 1 ? 1 : 3, e.clientX, e.clientY, true);
                    lastClickTime = 0;
                } else { lastClickTime = now; isPanning = true; lastX = e.clientX; lastY = e.clientY; }
            });

            wrapper.addEventListener('mousemove', e => {
                if (this.fsState.zoom > 1) {
                    if (state.interactionMode === 'pan') {
                        if (isPanning && e.buttons === 1) {
                            const rect = wrapper.getBoundingClientRect();
                            this.fsState.panX += (e.clientX - lastX) / rect.width * 100;
                            this.fsState.panY += (e.clientY - lastY) / rect.height * 100;
                            this.constrainPan();
                            this.applyTransform();
                            lastX = e.clientX;
                            lastY = e.clientY;
                        }
                    } else {
                        updateLight(e.clientX, e.clientY);
                    }
                } else {
                    updateLight(e.clientX, e.clientY);
                }
            });

            wrapper.addEventListener('mouseup', () => isPanning = false);
            wrapper.addEventListener('mouseleave', () => { isPanning = false; resetLight(); });
            wrapper.addEventListener('wheel', e => { e.preventDefault(); this.setZoom(this.fsState.zoom + (e.deltaY < 0 ? 0.5 : -0.5), e.clientX, e.clientY); }, { passive: false });
        },

        setZoom(newZoom, centerX = null, centerY = null, animate = false) {
            const oldZoom = this.fsState.zoom;
            this.fsState.zoom = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, newZoom));
            
            if (centerX !== null && centerY !== null && this.fsState.zoom !== oldZoom) {
                const wrapper = document.getElementById('fullscreen-card-wrapper');
                const rect = wrapper.getBoundingClientRect();
                const relX = (centerX - rect.left) / rect.width - 0.5;
                const relY = (centerY - rect.top) / rect.height - 0.5;
                const zoomDelta = this.fsState.zoom - oldZoom;
                this.fsState.panX -= relX * zoomDelta * 100;
                this.fsState.panY -= relY * zoomDelta * 100;
            }
            
            if (this.fsState.zoom === 1) { this.fsState.panX = 0; this.fsState.panY = 0; }
            this.constrainPan();
            
            const canvas = document.getElementById('fullscreen-card-canvas');
            if (animate) { canvas.classList.add('animating'); setTimeout(() => canvas.classList.remove('animating'), 150); }
            
            this.applyTransform();
            this.updateZoomLevel();
        },

        constrainPan() {
            if (this.fsState.zoom <= 1) { this.fsState.panX = 0; this.fsState.panY = 0; return; }
            const maxPan = (this.fsState.zoom - 1) * 50;
            this.fsState.panX = Math.max(-maxPan, Math.min(maxPan, this.fsState.panX));
            this.fsState.panY = Math.max(-maxPan, Math.min(maxPan, this.fsState.panY));
        },

        applyTransform() {
            const canvas = document.getElementById('fullscreen-card-canvas');
            canvas.style.transform = `scale(${this.fsState.zoom}) translate(${this.fsState.panX / this.fsState.zoom}%, ${this.fsState.panY / this.fsState.zoom}%)`;
        },

        updateZoomLevel() {
            document.getElementById('fs-zoom-level').textContent = `${this.fsState.zoom.toFixed(1)}x`;
        }
    };

    // ============================================
    // DEMO IMAGE GENERATOR (for testing)
    // ============================================
    const demoImages = {
        generateLayer(direction, width = 400, height = 557) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            const baseColor = '#2a4a6a';
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, width, height);

            let gradient;
            switch (direction) {
                case 'base':
                    gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.1)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.1)');
                    break;
                case 'north':
                    gradient = ctx.createLinearGradient(0, 0, 0, height);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.4)');
                    gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.2)');
                    break;
                case 'south':
                    gradient = ctx.createLinearGradient(0, height, 0, 0);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.4)');
                    gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.2)');
                    break;
                case 'east':
                    gradient = ctx.createLinearGradient(width, 0, 0, 0);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.4)');
                    gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.2)');
                    break;
                case 'west':
                    gradient = ctx.createLinearGradient(0, 0, width, 0);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.4)');
                    gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.2)');
                    break;
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 8;
            ctx.strokeRect(12, 12, width - 24, height - 24);

            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 2;
            ctx.strokeRect(24, 24, width - 48, height - 48);

            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(32, 60, width - 64, height * 0.45);

            if (direction !== 'base') {
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                const artX = 32, artY = 60, artW = width - 64, artH = height * 0.45;
                switch (direction) {
                    case 'north': ctx.fillRect(artX, artY, artW, artH * 0.3); break;
                    case 'south': ctx.fillRect(artX, artY + artH * 0.7, artW, artH * 0.3); break;
                    case 'east': ctx.fillRect(artX + artW * 0.7, artY, artW * 0.3, artH); break;
                    case 'west': ctx.fillRect(artX, artY, artW * 0.3, artH); break;
                }
            }

            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            ctx.fillRect(32, 20, width - 64, 32);

            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(32, height * 0.58, width - 64, height * 0.32);

            ctx.fillStyle = 'rgba(245, 245, 245, 0.7)';
            ctx.font = 'bold 14px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText('VERIFIED', width / 2, height - 20);

            return canvas.toDataURL('image/jpeg', 0.85);
        },

        generateAll() {
            return {
                base: this.generateLayer('base'),
                north: this.generateLayer('north'),
                south: this.generateLayer('south'),
                east: this.generateLayer('east'),
                west: this.generateLayer('west')
            };
        }
    };

    function loadImagesWithFallback() {
        const testImg = new Image();
        testImg.onload = () => {
            cardViewer.loadImages({
                base: 'base.JPG',
                north: 'north.JPG',
                south: 'south.JPG',
                east: 'east.JPG',
                west: 'west.JPG'
            });
        };
        testImg.onerror = () => {
            // Try lowercase
            const testImg2 = new Image();
            testImg2.onload = () => {
                cardViewer.loadImages({
                    base: 'base.jpg',
                    north: 'north.jpg',
                    south: 'south.jpg',
                    east: 'east.jpg',
                    west: 'west.jpg'
                });
            };
            testImg2.onerror = () => {
                cardViewer.loadImages(demoImages.generateAll());
            };
            testImg2.src = 'base.jpg';
        };
        testImg.src = 'base.JPG';
    }

    // ============================================
    // DATA DISPLAY MODULE
    // ============================================
    const dataDisplay = {
        loadData() {
            const raw = utils.safeLocalStorage('get', 'lumina-card-data');
            if (!raw) {
                console.warn('No card data found');
                return null;
            }
            
            try {
                return JSON.parse(raw);
            } catch (e) {
                console.error('Failed to parse card data:', e);
                return null;
            }
        },

        render(data) {
            if (!data) return;

            // Basic info
            document.getElementById('display-name').textContent = data.name || 'Untitled Card';
            document.getElementById('display-set').textContent = data.set || 'Unknown Set';
            document.getElementById('display-timestamp').textContent = data.timestamp || '--';

            // Number
            if (data.number) {
                document.getElementById('display-number').textContent = data.number;
            } else {
                document.getElementById('row-number').classList.add('hidden');
            }

            // Language
            if (data.language) {
                document.getElementById('display-language').textContent = LANGUAGE_MAP[data.language] || data.language;
            } else {
                document.getElementById('row-language').classList.add('hidden');
            }

            // Edition
            if (data.edition) {
                document.getElementById('display-edition').textContent = EDITION_MAP[data.edition] || data.edition;
            } else {
                document.getElementById('row-edition').classList.add('hidden');
            }

            // Grade
            if (data.grade) {
                document.getElementById('display-grade').textContent = GRADE_MAP[data.grade] || data.grade;
            } else {
                document.getElementById('row-grade').classList.add('hidden');
            }

            // Notes
            if (data.notes && data.notes.trim()) {
                document.getElementById('display-notes').textContent = data.notes;
                document.getElementById('notes-card').classList.remove('hidden');
            }

            // Links
            const links = data.links || {};
            let hasLinks = false;

            ['ebay', 'facebook', 'tcgplayer', 'mercari', 'other'].forEach(platform => {
                const url = links[platform];
                const linkEl = document.getElementById('link-' + platform);
                if (url && url.trim()) {
                    linkEl.href = url;
                    linkEl.classList.remove('hidden');
                    hasLinks = true;
                }
            });

            if (hasLinks) {
                document.getElementById('links-card').classList.remove('hidden');
            }
        }
    };

    // ============================================
    // EVENT HANDLERS
    // ============================================
    function setupEventListeners() {
        // Touch handlers
        elements.cardWrapper.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const now = Date.now();
                const dx = touch.clientX - state.lastTapX;
                const dy = touch.clientY - state.lastTapY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (now - state.lastTapTime < CONFIG.doubleTapDelay && distance < CONFIG.doubleTapDistance) {
                    e.preventDefault();
                    const newZoom = state.zoom > 1 ? 1 : 3;
                    cardViewer.setZoom(newZoom, touch.clientX, touch.clientY, true);
                    utils.vibrate(10);
                    state.lastTapTime = 0;
                } else {
                    state.lastTapTime = now;
                    state.lastTapX = touch.clientX;
                    state.lastTapY = touch.clientY;
                    state.isPanning = true;
                    state.lastX = touch.clientX;
                    state.lastY = touch.clientY;
                    cardViewer.updateLight(state.lastX, state.lastY);
                }
            } else if (e.touches.length === 2) {
                state.isPanning = false;
                state.initialPinchDistance = cardViewer.getPinchDistance(e.touches);
                state.initialPinchZoom = state.zoom;
            }
        }, { passive: false });

        elements.cardWrapper.addEventListener('touchmove', e => {
            e.preventDefault();
            
            if (e.touches.length === 1 && state.isPanning) {
                const t = e.touches[0];
                
                // Mode-aware behavior when zoomed
                if (state.zoom > 1) {
                    if (state.interactionMode === 'pan') {
                        const rect = elements.cardWrapper.getBoundingClientRect();
                        state.panX += (t.clientX - state.lastX) / rect.width * 100;
                        state.panY += (t.clientY - state.lastY) / rect.height * 100;
                        cardViewer.constrainPan();
                        cardViewer.applyTransform();
                    } else {
                        cardViewer.updateLight(t.clientX, t.clientY);
                    }
                } else {
                    cardViewer.updateLight(t.clientX, t.clientY);
                }
                state.lastX = t.clientX;
                state.lastY = t.clientY;
                
            } else if (e.touches.length === 2) {
                const currentDistance = cardViewer.getPinchDistance(e.touches);
                const center = cardViewer.getPinchCenter(e.touches);
                const scale = currentDistance / state.initialPinchDistance;
                cardViewer.setZoom(state.initialPinchZoom * scale, center.x, center.y);
            }
        }, { passive: false });

        elements.cardWrapper.addEventListener('touchend', e => {
            if (e.touches.length === 0) {
                state.isPanning = false;
                cardViewer.resetLight();
            } else if (e.touches.length === 1) {
                state.lastX = e.touches[0].clientX;
                state.lastY = e.touches[0].clientY;
                state.isPanning = true;
            }
        }, { passive: true });

        // Mouse handlers
        let lastClickTime = 0;

        elements.cardWrapper.addEventListener('mousedown', e => {
            const now = Date.now();
            if (now - lastClickTime < CONFIG.doubleTapDelay) {
                const newZoom = state.zoom > 1 ? 1 : 3;
                cardViewer.setZoom(newZoom, e.clientX, e.clientY, true);
                lastClickTime = 0;
            } else {
                lastClickTime = now;
                state.isPanning = true;
                state.lastX = e.clientX;
                state.lastY = e.clientY;
            }
        });

        elements.cardWrapper.addEventListener('mousemove', e => {
            if (state.zoom > 1) {
                if (state.interactionMode === 'pan') {
                    if (state.isPanning && e.buttons === 1) {
                        const rect = elements.cardWrapper.getBoundingClientRect();
                        state.panX += (e.clientX - state.lastX) / rect.width * 100;
                        state.panY += (e.clientY - state.lastY) / rect.height * 100;
                        cardViewer.constrainPan();
                        cardViewer.applyTransform();
                        state.lastX = e.clientX;
                        state.lastY = e.clientY;
                    }
                } else {
                    cardViewer.updateLight(e.clientX, e.clientY);
                }
            } else {
                cardViewer.updateLight(e.clientX, e.clientY);
            }
        });

        elements.cardWrapper.addEventListener('mouseup', () => state.isPanning = false);
        elements.cardWrapper.addEventListener('mouseleave', () => {
            state.isPanning = false;
            cardViewer.resetLight();
        });

        elements.cardWrapper.addEventListener('wheel', e => {
            e.preventDefault();
            cardViewer.setZoom(state.zoom + (e.deltaY < 0 ? 0.5 : -0.5), e.clientX, e.clientY);
        }, { passive: false });

        // Zoom buttons
        document.getElementById('zoom-in-btn').addEventListener('click', () => {
            cardViewer.setZoom(state.zoom + 0.5, null, null, true);
            utils.vibrate(5);
        });
        
        document.getElementById('zoom-out-btn').addEventListener('click', () => {
            cardViewer.setZoom(state.zoom - 0.5, null, null, true);
            utils.vibrate(5);
        });

        // Share button
        document.getElementById('share-btn').addEventListener('click', async () => {
            utils.vibrate(5);
            const title = document.getElementById('display-name').textContent + ' - Lumina Verified';
            
            if (navigator.share) {
                try { 
                    await navigator.share({ title, url: location.href }); 
                } catch (e) {
                    // User cancelled or error
                }
            } else if (navigator.clipboard) {
                await navigator.clipboard.writeText(location.href);
                elements.toast.classList.add('visible');
                setTimeout(() => elements.toast.classList.remove('visible'), 2000);
            }
        });

        // Back button
        document.getElementById('back-btn').addEventListener('click', () => {
            window.location.href = 'lumina-draft.html';
        });
    }

    // ============================================
    // INITIALIZATION
    // ============================================
    function init() {
        // Cache DOM references
        elements = {
            cardWrapper: document.getElementById('card-wrapper'),
            cardCanvas: document.getElementById('card-canvas'),
            lightGlow: document.getElementById('light-glow'),
            zoomPill: document.getElementById('zoom-pill'),
            toast: document.getElementById('toast')
        };

        // Initialize modules
        cardViewer.init();
        forensicAnalysis.init();
        modeToggle.init();
        fullscreen.init();
        
        // Load and render data
        const data = dataDisplay.loadData();
        dataDisplay.render(data);
        
        // Load images
        loadImagesWithFallback();
        
        // Setup events
        setupEventListeners();
        setupFullscreenEvents();

        // Global error handling
        window.addEventListener('error', e => console.error('Global error:', e.error));
        window.addEventListener('unhandledrejection', e => console.error('Unhandled rejection:', e.reason));
    }

    function setupFullscreenEvents() {
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const fullscreenClose = document.getElementById('fullscreen-close');
        const fullscreenCardArea = document.getElementById('fullscreen-card-area');
        const fsZoomIn = document.getElementById('fs-zoom-in');
        const fsZoomOut = document.getElementById('fs-zoom-out');
        
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', () => fullscreen.enter());
        }
        
        if (fullscreenClose) {
            fullscreenClose.addEventListener('click', () => fullscreen.exit());
        }
        
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                if (fullscreen.isActive) fullscreen.exit();
            }
        });
        
        if (fullscreenCardArea) {
            fullscreenCardArea.addEventListener('click', e => {
                if (e.target.id === 'fullscreen-card-area') fullscreen.exit();
            });
        }
        
        if (fsZoomIn) {
            fsZoomIn.addEventListener('click', () => {
                fullscreen.setZoom(fullscreen.fsState.zoom + 0.5, null, null, true);
                utils.vibrate(5);
            });
        }
        
        if (fsZoomOut) {
            fsZoomOut.addEventListener('click', () => {
                fullscreen.setZoom(fullscreen.fsState.zoom - 0.5, null, null, true);
                utils.vibrate(5);
            });
        }
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    // Return public API
    return {
        getState: () => ({ ...state }),
        utils
    };
})();
    </script>
</body>
</html>
