<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="theme-color" content="#1a1a1a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Lumina - Draft</title>
    <style>
/* ============================================
   DESIGN TOKENS
   ============================================ */
:root {
    /* Colors */
    --bg-primary: #1a1a1a;
    --bg-secondary: #242424;
    --bg-tertiary: #2a2a2a;
    --text-primary: #f5f5f5;
    --text-secondary: #888;
    --text-muted: #666;
    
    /* Borders */
    --border-subtle: rgba(255,255,255,0.06);
    --border-light: rgba(255,255,255,0.08);
    --border-medium: rgba(255,255,255,0.1);
    --border-strong: rgba(255,255,255,0.15);
    
    /* Accents */
    --accent-gold: #E8B84A;
    --accent-gold-dark: #D4A43A;
    --accent-green: #22C55E;
    --accent-red: #EF4444;
    --accent-yellow: #EAB308;
    
    /* Shadows */
    --shadow-card: 0 2px 8px rgba(0,0,0,0.3), 0 8px 24px rgba(0,0,0,0.4), 0 24px 48px rgba(0,0,0,0.3);
    
    /* Radii */
    --radius-sm: 8px;
    --radius-md: 10px;
    --radius-lg: 12px;
    
    /* Sizing */
    --touch-target: 44px;
    
    /* Transitions */
    --transition-fast: 0.15s ease;
    --transition-medium: 0.2s ease;
}

/* ============================================
   RESET & BASE
   ============================================ */
* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
    min-height: 100%;
    min-height: -webkit-fill-available;
    background: var(--bg-primary);
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', system-ui, sans-serif;
    color: var(--text-primary);
    -webkit-tap-highlight-color: transparent;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

@media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* ============================================
   HEADER
   ============================================ */
.header {
    position: sticky;
    top: 0;
    height: 56px;
    padding: 0 16px;
    padding-top: env(safe-area-inset-top);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 300;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border-subtle);
}

.header-btn {
    position: absolute;
    width: var(--touch-target);
    height: var(--touch-target);
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: transparent;
    cursor: pointer;
    border-radius: 50%;
    transition: background var(--transition-fast);
}

.header-btn:hover,
.header-btn:focus-visible { background: rgba(255,255,255,0.08); }
.header-btn:focus-visible { outline: 2px solid var(--accent-gold); outline-offset: 2px; }
.header-btn svg { width: 22px; height: 22px; color: var(--text-primary); }

.back-btn { left: 8px; }
.wordmark { font-size: 18px; font-weight: 600; letter-spacing: 0.02em; color: var(--text-primary); }

/* ============================================
   LAYOUT
   ============================================ */
.main-container {
    max-width: 960px;
    margin: 0 auto;
    padding: 24px 16px 48px;
    padding-bottom: calc(48px + env(safe-area-inset-bottom));
    display: flex;
    flex-direction: column;
    gap: 24px;
}

@media (min-width: 768px) {
    .main-container {
        flex-direction: row;
        align-items: flex-start;
        gap: 32px;
        padding: 32px 24px 48px;
    }
}

/* ============================================
   CARD VIEWER
   ============================================ */
.card-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
}

@media (min-width: 768px) {
    .card-section {
        position: sticky;
        top: 80px;
    }
}

.card-wrapper {
    position: relative;
    width: min(260px, 65vw);
    aspect-ratio: 1340 / 1864;
    border-radius: var(--radius-lg);
    overflow: hidden;
    touch-action: none;
    box-shadow: var(--shadow-card);
    background: var(--bg-tertiary);
    -webkit-user-select: none;
    user-select: none;
}

@media (min-width: 768px) {
    .card-wrapper { width: 280px; }
}

.card-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    transform-origin: center center;
    will-change: transform;
}

.card-canvas.animating {
    transition: transform 0.1s ease-out;
}

.card-layer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    pointer-events: none;
    -webkit-user-drag: none;
    will-change: opacity;
}

.layer-base { z-index: 1; }
.layer-north { z-index: 2; opacity: 0; }
.layer-south { z-index: 3; opacity: 0; }
.layer-east { z-index: 4; opacity: 0; }
.layer-west { z-index: 5; opacity: 0; }

/* Card placeholder when no image loaded */
.card-placeholder {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
    color: var(--text-muted);
    z-index: 0;
}

.card-placeholder svg { width: 48px; height: 48px; opacity: 0.5; }
.card-placeholder span { font-size: 13px; }

.card-controls {
    display: flex;
    gap: 8px;
}

.card-control-btn {
    width: var(--touch-target);
    height: var(--touch-target);
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: var(--bg-secondary);
    cursor: pointer;
    border-radius: var(--radius-md);
    border: 1px solid var(--border-light);
    transition: background var(--transition-fast);
}

.card-control-btn:hover,
.card-control-btn:focus-visible { background: var(--bg-tertiary); }
.card-control-btn:focus-visible { outline: 2px solid var(--accent-gold); outline-offset: 2px; }
.card-control-btn svg { width: 18px; height: 18px; color: var(--text-secondary); }
.card-control-btn:hover svg { color: var(--text-primary); }

.zoom-hint {
    font-size: 12px;
    color: var(--text-muted);
    text-align: center;
    display: none;
}

@media (max-width: 767px) and (hover: none) {
    .zoom-hint { display: block; }
}

/* ============================================
   DETAILS SECTION
   ============================================ */
.details-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 16px;
    min-width: 0;
}

/* Status Card */
.status-card {
    background: var(--bg-secondary);
    border-radius: var(--radius-lg);
    padding: 16px;
    border: 1px solid var(--border-light);
}

.status-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    background: rgba(234, 179, 8, 0.15);
    border: 1px solid rgba(234, 179, 8, 0.3);
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
    color: var(--accent-yellow);
    text-transform: uppercase;
    letter-spacing: 0.03em;
}

.status-badge svg { width: 14px; height: 14px; }

.timestamp {
    margin-top: 12px;
    font-size: 14px;
    color: var(--text-secondary);
}

.timestamp strong {
    color: var(--text-primary);
    font-weight: 500;
}

/* Auto-detected banner */
.auto-detected-banner {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 14px;
    background: rgba(34, 197, 94, 0.1);
    border: 1px solid rgba(34, 197, 94, 0.2);
    border-radius: var(--radius-md);
    margin-bottom: 14px;
}

.auto-detected-banner svg {
    width: 18px;
    height: 18px;
    color: var(--accent-green);
    flex-shrink: 0;
}

.auto-detected-banner span {
    font-size: 13px;
    color: var(--accent-green);
}

.auto-detected-banner.loading span {
    color: var(--text-secondary);
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.spinner {
    width: 18px;
    height: 18px;
    border: 2px solid rgba(34, 197, 94, 0.3);
    border-top-color: var(--accent-green);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

/* ============================================
   FORM SECTIONS
   ============================================ */
.form-section {
    background: var(--bg-secondary);
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-light);
    overflow: hidden;
}

.section-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 16px;
    cursor: pointer;
    user-select: none;
    transition: background var(--transition-fast);
    min-height: var(--touch-target);
}

.section-header:hover { background: rgba(255,255,255,0.03); }
.section-header:focus-visible { outline: 2px solid var(--accent-gold); outline-offset: -2px; }

.section-title {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
}

.section-title svg {
    width: 18px;
    height: 18px;
    color: var(--text-secondary);
}

.section-toggle {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform var(--transition-medium);
}

.section-toggle svg {
    width: 16px;
    height: 16px;
    color: var(--text-muted);
}

.form-section.collapsed .section-toggle {
    transform: rotate(-90deg);
}

.section-content {
    padding: 0 16px 16px;
    display: flex;
    flex-direction: column;
    gap: 14px;
}

.form-section.collapsed .section-content {
    display: none;
}

/* ============================================
   FORM ELEMENTS
   ============================================ */
.form-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.form-label {
    font-size: 12px;
    font-weight: 500;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.03em;
    display: flex;
    align-items: center;
    gap: 6px;
}

.form-label .auto-badge {
    font-size: 9px;
    padding: 2px 6px;
    background: rgba(34, 197, 94, 0.2);
    color: var(--accent-green);
    border-radius: 4px;
    font-weight: 600;
}

.form-input,
.form-select,
.form-textarea {
    padding: 12px 14px;
    min-height: var(--touch-target);
    background: var(--bg-primary);
    border: 1px solid var(--border-medium);
    border-radius: var(--radius-sm);
    font-size: 16px;
    color: var(--text-primary);
    font-family: inherit;
    transition: border-color var(--transition-fast), background var(--transition-fast);
}

.form-input:focus,
.form-select:focus,
.form-textarea:focus {
    outline: none;
    border-color: var(--border-strong);
    background: #222;
}

.form-input::placeholder { color: #555; }

.form-input.auto-filled,
.form-select.auto-filled {
    background: rgba(34, 197, 94, 0.05);
    border-color: rgba(34, 197, 94, 0.2);
}

.form-input.error {
    border-color: var(--accent-red);
}

.form-select {
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 12px center;
    padding-right: 40px;
}

.form-textarea {
    min-height: 80px;
    resize: vertical;
    line-height: 1.5;
}

.form-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
}

@media (max-width: 400px) {
    .form-row { grid-template-columns: 1fr; }
}

/* Link input with icon */
.link-input-group {
    position: relative;
}

.link-input-group .form-input {
    padding-left: 44px;
    width: 100%;
}

.link-icon {
    position: absolute;
    left: 14px;
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    color: var(--text-muted);
    pointer-events: none;
}

.input-error {
    color: var(--accent-red);
    font-size: 12px;
    margin-top: 6px;
    display: flex;
    align-items: flex-start;
    gap: 4px;
}

/* ============================================
   BUTTONS
   ============================================ */
.action-section {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 8px;
}

.btn-primary {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 16px 24px;
    min-height: 52px;
    background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-gold-dark) 100%);
    border: none;
    border-radius: var(--radius-lg);
    font-size: 15px;
    font-weight: 600;
    color: var(--bg-primary);
    cursor: pointer;
    transition: transform var(--transition-fast), box-shadow var(--transition-fast);
    -webkit-tap-highlight-color: transparent;
}

.btn-primary:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 16px rgba(232, 184, 74, 0.3);
}

.btn-primary:active { transform: translateY(0); }
.btn-primary:focus-visible { outline: 2px solid var(--text-primary); outline-offset: 2px; }
.btn-primary svg { width: 18px; height: 18px; }

.secondary-actions {
    display: flex;
    gap: 8px;
}

.btn-secondary {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 12px 14px;
    min-height: var(--touch-target);
    background: transparent;
    border: 1px solid var(--border-strong);
    border-radius: var(--radius-md);
    font-size: 13px;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all var(--transition-fast);
}

.btn-secondary:hover {
    background: rgba(255,255,255,0.05);
    border-color: var(--border-strong);
    color: var(--text-primary);
}

.btn-secondary:focus-visible { outline: 2px solid var(--accent-gold); outline-offset: 2px; }
.btn-secondary svg { width: 15px; height: 15px; }

.btn-danger:hover {
    border-color: rgba(239, 68, 68, 0.5);
    color: var(--accent-red);
}

/* ============================================
   MODAL
   ============================================ */
.modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.8);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 500;
    opacity: 0;
    visibility: hidden;
    transition: opacity var(--transition-medium), visibility var(--transition-medium);
    padding: 24px;
    padding-bottom: calc(24px + env(safe-area-inset-bottom));
}

.modal-overlay.visible {
    opacity: 1;
    visibility: visible;
}

.modal {
    background: var(--bg-secondary);
    border-radius: 16px;
    padding: 24px;
    max-width: 400px;
    width: 100%;
    border: 1px solid var(--border-medium);
    transform: scale(0.95);
    transition: transform var(--transition-medium);
}

.modal-overlay.visible .modal {
    transform: scale(1);
}

.modal-icon {
    width: 48px;
    height: 48px;
    background: rgba(234, 179, 8, 0.15);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
}

.modal-icon svg { width: 24px; height: 24px; color: var(--accent-yellow); }

.modal-title {
    font-size: 18px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 8px;
}

.modal-message {
    font-size: 14px;
    color: var(--text-secondary);
    line-height: 1.5;
    margin-bottom: 24px;
}

.modal-actions {
    display: flex;
    gap: 12px;
}

.modal-btn {
    flex: 1;
    padding: 14px 16px;
    min-height: var(--touch-target);
    border-radius: var(--radius-md);
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all var(--transition-fast);
}

.modal-btn-cancel {
    background: transparent;
    border: 1px solid var(--border-strong);
    color: var(--text-secondary);
}

.modal-btn-cancel:hover {
    background: rgba(255,255,255,0.05);
    color: var(--text-primary);
}

.modal-btn-confirm {
    background: var(--accent-gold);
    border: none;
    color: var(--bg-primary);
}

.modal-btn-confirm:hover { background: var(--accent-gold-dark); }

/* ============================================
   OVERLAYS & INDICATORS
   ============================================ */
.light-glow {
    position: fixed;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255,220,150,0.12) 0%, transparent 70%);
    pointer-events: none;
    z-index: 100;
    transform: translate(-50%, -50%);
    opacity: 0;
    transition: opacity var(--transition-fast);
}

.light-glow.visible { opacity: 1; }

.zoom-pill {
    position: fixed;
    top: 70px;
    left: 50%;
    transform: translateX(-50%);
    padding: 6px 12px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-medium);
    border-radius: 16px;
    font-size: 12px;
    font-weight: 600;
    color: var(--text-primary);
    z-index: 200;
    opacity: 0;
    pointer-events: none;
    transition: opacity var(--transition-medium);
}

.zoom-pill.visible { opacity: 1; }

/* ============================================
   TEXTURE SLIDER
   ============================================ */
.texture-layer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    pointer-events: none;
    z-index: 10;
    clip-path: inset(0 100% 0 0);
    filter: grayscale(100%) contrast(1.3) brightness(1.1);
    mix-blend-mode: luminosity;
}

.texture-slider {
    position: absolute;
    top: 0;
    left: 0;
    width: 4px;
    height: 100%;
    background: var(--accent-gold);
    z-index: 20;
    cursor: ew-resize;
    transform: translateX(-50%);
    box-shadow: 0 0 8px rgba(0,0,0,0.5);
    transition: opacity var(--transition-fast);
}

.texture-slider::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 36px;
    height: 36px;
    background: var(--accent-gold);
    border-radius: 50%;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
}

.texture-slider::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%231a1a1a' stroke-width='2.5'%3E%3Cpath d='M18 8l4 4-4 4M6 8l-4 4 4 4'/%3E%3C/svg%3E") center/contain no-repeat;
}

.texture-slider-track {
    position: absolute;
    bottom: 12px;
    left: 12px;
    right: 12px;
    height: 32px;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border-radius: 16px;
    z-index: 15;
    display: flex;
    align-items: center;
    padding: 0 12px;
    gap: 8px;
    opacity: 0;
    transition: opacity var(--transition-medium);
    pointer-events: none;
}

.card-wrapper:hover .texture-slider-track,
.card-wrapper:focus-within .texture-slider-track,
.card-wrapper.slider-active .texture-slider-track {
    opacity: 1;
    pointer-events: auto;
}

@media (hover: none) {
    .texture-slider-track {
        opacity: 1;
        pointer-events: auto;
    }
}

.texture-label {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-secondary);
    white-space: nowrap;
}

.texture-label.active {
    color: var(--accent-gold);
}

.texture-track-bar {
    flex: 1;
    height: 4px;
    background: rgba(255,255,255,0.2);
    border-radius: 2px;
    position: relative;
}

.texture-track-fill {
    position: absolute;
    top: 0; left: 0;
    height: 100%;
    background: var(--accent-gold);
    border-radius: 2px;
    width: 0%;
}

/* ============================================
   FULLSCREEN MODE
   ============================================ */
.fullscreen-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 36px;
    height: 36px;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: var(--radius-sm);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 25;
    opacity: 0;
    transition: opacity var(--transition-medium), background var(--transition-fast);
}

.card-wrapper:hover .fullscreen-btn,
.card-wrapper:focus-within .fullscreen-btn {
    opacity: 1;
}

@media (hover: none) {
    .fullscreen-btn { opacity: 1; }
}

.fullscreen-btn:hover,
.fullscreen-btn:focus-visible {
    background: rgba(0,0,0,0.8);
}

.fullscreen-btn:focus-visible {
    outline: 2px solid var(--accent-gold);
    outline-offset: 2px;
}

.fullscreen-btn svg {
    width: 18px;
    height: 18px;
    color: var(--text-primary);
}

/* Fullscreen overlay state */
.fullscreen-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: #000;
    z-index: 1000;
    flex-direction: column;
}

.fullscreen-overlay.active {
    display: flex;
}

.fullscreen-header {
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 56px;
    padding: 0 16px;
    padding-top: env(safe-area-inset-top);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, transparent 100%);
    z-index: 1010;
}

.fullscreen-title {
    font-size: 16px;
    font-weight: 600;
    color: var(--text-primary);
}

.fullscreen-close {
    width: var(--touch-target);
    height: var(--touch-target);
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.1);
    border: none;
    border-radius: 50%;
    cursor: pointer;
    transition: background var(--transition-fast);
}

.fullscreen-close:hover,
.fullscreen-close:focus-visible {
    background: rgba(255,255,255,0.2);
}

.fullscreen-close:focus-visible {
    outline: 2px solid var(--accent-gold);
    outline-offset: 2px;
}

.fullscreen-close svg {
    width: 24px;
    height: 24px;
    color: var(--text-primary);
}

.fullscreen-card-area {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 60px 16px 100px;
    overflow: hidden;
}

.fullscreen-card-wrapper {
    position: relative;
    width: 100%;
    max-width: min(90vw, 600px);
    max-height: 100%;
    aspect-ratio: 1340 / 1864;
    border-radius: var(--radius-lg);
    overflow: hidden;
    touch-action: none;
    box-shadow: var(--shadow-card);
    -webkit-user-select: none;
    user-select: none;
}

@media (orientation: landscape) {
    .fullscreen-card-wrapper {
        max-width: none;
        width: auto;
        height: 100%;
        max-height: calc(100vh - 160px);
    }
}

.fullscreen-controls {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    padding: 16px;
    padding-bottom: calc(16px + env(safe-area-inset-bottom));
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 100%);
    display: flex;
    flex-direction: column;
    gap: 12px;
    z-index: 1010;
}

.fullscreen-zoom-controls {
    display: flex;
    justify-content: center;
    gap: 12px;
}

.fullscreen-zoom-btn {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: var(--radius-md);
    cursor: pointer;
    transition: background var(--transition-fast);
}

.fullscreen-zoom-btn:hover,
.fullscreen-zoom-btn:focus-visible {
    background: rgba(255,255,255,0.2);
}

.fullscreen-zoom-btn svg {
    width: 22px;
    height: 22px;
    color: var(--text-primary);
}

.fullscreen-zoom-level {
    min-width: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
}

.fullscreen-texture-slider {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 0 8px;
}

.fullscreen-texture-slider .texture-label {
    font-size: 11px;
}

.fullscreen-texture-slider .texture-track-bar {
    height: 6px;
}

/* Hide body scroll when fullscreen */
body.fullscreen-active {
    overflow: hidden;
    position: fixed;
    width: 100%;
    height: 100%;
}

/* Screen reader only */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}
    </style>
</head>
<body>
    <!-- ============================================
         HEADER
         ============================================ -->
    <header class="header">
        <button class="header-btn back-btn" id="back-btn" aria-label="Go back">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
        </button>
        <span class="wordmark">Lumina</span>
    </header>

    <!-- ============================================
         MAIN CONTENT
         ============================================ -->
    <main class="main-container">
        <!-- Card Preview Section -->
        <section class="card-section" aria-label="Card preview">
            <div class="card-wrapper" id="card-wrapper" role="img" aria-label="Interactive card preview - drag to change lighting, pinch to zoom, slide to reveal texture">
                <div class="card-canvas" id="card-canvas">
                    <!-- Placeholder shown when no images loaded -->
                    <div class="card-placeholder" id="card-placeholder">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <path d="M21 15l-5-5L5 21"/>
                        </svg>
                        <span>Card preview</span>
                    </div>
                    <!-- RTI Layers - loaded dynamically -->
                    <img class="card-layer layer-base" id="layer-base" alt="" src="" loading="eager">
                    <img class="card-layer layer-north" id="layer-north" alt="" src="" loading="eager">
                    <img class="card-layer layer-south" id="layer-south" alt="" src="" loading="eager">
                    <img class="card-layer layer-east" id="layer-east" alt="" src="" loading="eager">
                    <img class="card-layer layer-west" id="layer-west" alt="" src="" loading="eager">
                    <!-- Texture Map Layer -->
                    <img class="card-layer texture-layer" id="texture-layer" alt="" src="" loading="eager">
                </div>
                <!-- Texture Slider Handle -->
                <div class="texture-slider" id="texture-slider" role="slider" aria-label="Texture reveal slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div>
                <!-- Fullscreen Button -->
                <button class="fullscreen-btn" id="fullscreen-btn" aria-label="Enter fullscreen mode">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                    </svg>
                </button>
                <!-- Texture Slider Track (bottom bar) -->
                <div class="texture-slider-track" id="texture-slider-track">
                    <span class="texture-label active" id="label-color">COLOR</span>
                    <div class="texture-track-bar">
                        <div class="texture-track-fill" id="texture-track-fill"></div>
                    </div>
                    <span class="texture-label" id="label-texture">TEXTURE</span>
                </div>
            </div>
            <div class="card-controls">
                <button class="card-control-btn" id="zoom-out-btn" aria-label="Zoom out">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
                <button class="card-control-btn" id="zoom-in-btn" aria-label="Zoom in">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
            </div>
            <p class="zoom-hint">Pinch to zoom â€¢ Double-tap to toggle</p>
        </section>

        <!-- Details Section -->
        <section class="details-section" aria-label="Card details form">
            <!-- Status -->
            <div class="status-card">
                <div class="status-badge">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                    </svg>
                    Draft
                </div>
                <p class="timestamp">Captured: <strong id="capture-time">â€”</strong></p>
            </div>

            <!-- Card Info Section -->
            <div class="form-section" id="section-info">
                <div class="section-header" role="button" tabindex="0" aria-expanded="true" aria-controls="section-info-content" onclick="Lumina.toggleSection('section-info')" onkeydown="Lumina.handleSectionKeydown(event, 'section-info')">
                    <div class="section-title">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            <line x1="3" y1="9" x2="21" y2="9"/>
                            <line x1="9" y1="21" x2="9" y2="9"/>
                        </svg>
                        Card Information
                    </div>
                    <div class="section-toggle" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"/>
                        </svg>
                    </div>
                </div>
                <div class="section-content" id="section-info-content">
                    <div class="auto-detected-banner loading" id="auto-detect-banner">
                        <div class="spinner" id="detect-spinner"></div>
                        <span id="detect-status">Analyzing card...</span>
                    </div>

                    <div class="form-group">
                        <label class="form-label" for="card-name">
                            Card Name
                            <span class="auto-badge">AUTO</span>
                        </label>
                        <input type="text" class="form-input auto-filled" id="card-name" name="card-name" placeholder="Detecting..." maxlength="200" autocomplete="off">
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label" for="card-set">
                                Set
                                <span class="auto-badge">AUTO</span>
                            </label>
                            <input type="text" class="form-input auto-filled" id="card-set" name="card-set" placeholder="Detecting..." maxlength="100" autocomplete="off">
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="card-number">Number</label>
                            <input type="text" class="form-input" id="card-number" name="card-number" placeholder="e.g., 54/99" maxlength="20" autocomplete="off">
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label" for="card-language">Language</label>
                            <select class="form-select" id="card-language" name="card-language">
                                <option value="EN" selected>English</option>
                                <option value="JP">Japanese</option>
                                <option value="KR">Korean</option>
                                <option value="ZH">Chinese</option>
                                <option value="DE">German</option>
                                <option value="FR">French</option>
                                <option value="IT">Italian</option>
                                <option value="ES">Spanish</option>
                                <option value="PT">Portuguese</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="card-edition">Edition</label>
                            <select class="form-select" id="card-edition" name="card-edition">
                                <option value="UNL" selected>Unlimited</option>
                                <option value="1ST">1st Edition</option>
                                <option value="SHD">Shadowless</option>
                                <option value="PRO">Promo</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Condition Assessment Section -->
            <div class="form-section collapsed" id="section-condition">
                <div class="section-header" role="button" tabindex="0" aria-expanded="false" aria-controls="section-condition-content" onclick="Lumina.toggleSection('section-condition')" onkeydown="Lumina.handleSectionKeydown(event, 'section-condition')">
                    <div class="section-title">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                            <polyline points="14 2 14 8 20 8"/>
                            <line x1="16" y1="13" x2="8" y2="13"/>
                            <line x1="16" y1="17" x2="8" y2="17"/>
                        </svg>
                        Condition Assessment
                    </div>
                    <div class="section-toggle" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"/>
                        </svg>
                    </div>
                </div>
                <div class="section-content" id="section-condition-content">
                    <div class="form-group">
                        <label class="form-label" for="card-grade">Grade Estimate</label>
                        <select class="form-select" id="card-grade" name="card-grade">
                            <option value="" selected>Select grade...</option>
                            <option value="M">Mint (M)</option>
                            <option value="NM">Near Mint (NM)</option>
                            <option value="LP">Lightly Played (LP)</option>
                            <option value="MP">Moderately Played (MP)</option>
                            <option value="HP">Heavily Played (HP)</option>
                            <option value="DMG">Damaged (DMG)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label" for="card-notes">Condition Notes</label>
                        <textarea class="form-textarea" id="card-notes" name="card-notes" placeholder="Describe any scratches, whitening, centering issues, surface wear..." maxlength="1000"></textarea>
                    </div>
                </div>
            </div>

            <!-- Marketplace Links Section -->
            <div class="form-section collapsed" id="section-links">
                <div class="section-header" role="button" tabindex="0" aria-expanded="false" aria-controls="section-links-content" onclick="Lumina.toggleSection('section-links')" onkeydown="Lumina.handleSectionKeydown(event, 'section-links')">
                    <div class="section-title">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                        </svg>
                        Marketplace Links
                    </div>
                    <div class="section-toggle" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"/>
                        </svg>
                    </div>
                </div>
                <div class="section-content" id="section-links-content">
                    <div class="form-group">
                        <label class="form-label" for="link-ebay">eBay</label>
                        <div class="link-input-group">
                            <svg class="link-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                                <rect x="3" y="3" width="18" height="18" rx="3"/>
                            </svg>
                            <input type="url" class="form-input" id="link-ebay" name="link-ebay" placeholder="https://www.ebay.com/itm/..." inputmode="url">
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label" for="link-facebook">Facebook Marketplace</label>
                        <div class="link-input-group">
                            <svg class="link-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                                <circle cx="12" cy="12" r="10"/>
                            </svg>
                            <input type="url" class="form-input" id="link-facebook" name="link-facebook" placeholder="https://www.facebook.com/marketplace/item/..." inputmode="url">
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label" for="link-tcgplayer">TCGPlayer</label>
                        <div class="link-input-group">
                            <svg class="link-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                                <rect x="2" y="3" width="20" height="14" rx="2"/>
                            </svg>
                            <input type="url" class="form-input" id="link-tcgplayer" name="link-tcgplayer" placeholder="https://www.tcgplayer.com/product/..." inputmode="url">
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label" for="link-mercari">Mercari</label>
                        <div class="link-input-group">
                            <svg class="link-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                                <circle cx="12" cy="12" r="10"/>
                            </svg>
                            <input type="url" class="form-input" id="link-mercari" name="link-mercari" placeholder="https://www.mercari.com/us/item/..." inputmode="url">
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label" for="link-other">Other Link</label>
                        <div class="link-input-group">
                            <svg class="link-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                                <circle cx="12" cy="12" r="10"/>
                                <line x1="2" y1="12" x2="22" y2="12"/>
                            </svg>
                            <input type="url" class="form-input" id="link-other" name="link-other" placeholder="https://..." inputmode="url">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="action-section">
                <button class="btn-primary" id="generate-proof-btn" type="button">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                    </svg>
                    Generate Proof
                </button>
                <div class="secondary-actions">
                    <button class="btn-secondary" id="retake-btn" type="button">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <path d="M23 4v6h-6"/>
                            <path d="M1 20v-6h6"/>
                            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                        </svg>
                        Retake
                    </button>
                    <button class="btn-secondary btn-danger" id="delete-btn" type="button">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <polyline points="3 6 5 6 21 6"/>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                        </svg>
                        Delete
                    </button>
                </div>
            </div>
        </section>
    </main>

    <!-- ============================================
         MODAL
         ============================================ -->
    <div class="modal-overlay" id="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="modal-title">
        <div class="modal">
            <div class="modal-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                </svg>
            </div>
            <h2 class="modal-title" id="modal-title">Lock this Digital Twin?</h2>
            <p class="modal-message">
                This Digital Twin will be permanently recorded and cannot be edited or deleted. The timestamp and scan data will be locked forever as proof of authenticity.
            </p>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-cancel" id="modal-cancel" type="button">Cancel</button>
                <button class="modal-btn modal-btn-confirm" id="modal-confirm" type="button">Lock Forever</button>
            </div>
        </div>
    </div>

    <!-- Fullscreen Overlay -->
    <div class="fullscreen-overlay" id="fullscreen-overlay" role="dialog" aria-modal="true" aria-label="Fullscreen card viewer">
        <div class="fullscreen-header">
            <span class="fullscreen-title">Inspect Card</span>
            <button class="fullscreen-close" id="fullscreen-close" aria-label="Exit fullscreen">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>
        </div>
        <div class="fullscreen-card-area">
            <div class="fullscreen-card-wrapper" id="fullscreen-card-wrapper">
                <div class="card-canvas" id="fullscreen-card-canvas">
                    <img class="card-layer layer-base" id="fs-layer-base" alt="" src="" loading="eager">
                    <img class="card-layer layer-north" id="fs-layer-north" alt="" src="" loading="eager">
                    <img class="card-layer layer-south" id="fs-layer-south" alt="" src="" loading="eager">
                    <img class="card-layer layer-east" id="fs-layer-east" alt="" src="" loading="eager">
                    <img class="card-layer layer-west" id="fs-layer-west" alt="" src="" loading="eager">
                    <img class="card-layer texture-layer" id="fs-texture-layer" alt="" src="" loading="eager">
                </div>
                <div class="texture-slider" id="fs-texture-slider" role="slider" aria-label="Texture reveal slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div>
            </div>
        </div>
        <div class="fullscreen-controls">
            <div class="fullscreen-texture-slider">
                <span class="texture-label active" id="fs-label-color">COLOR</span>
                <div class="texture-track-bar">
                    <div class="texture-track-fill" id="fs-texture-track-fill"></div>
                </div>
                <span class="texture-label" id="fs-label-texture">TEXTURE</span>
            </div>
            <div class="fullscreen-zoom-controls">
                <button class="fullscreen-zoom-btn" id="fs-zoom-out" aria-label="Zoom out">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
                <span class="fullscreen-zoom-level" id="fs-zoom-level">1.0Ã—</span>
                <button class="fullscreen-zoom-btn" id="fs-zoom-in" aria-label="Zoom in">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Overlays -->
    <div class="light-glow" id="light-glow" aria-hidden="true"></div>
    <div class="zoom-pill" id="zoom-pill" aria-live="polite">1.0Ã—</div>

    <!-- ============================================
         JAVASCRIPT
         ============================================ -->
    <script>
/**
 * Lumina Draft Controller
 * Modular architecture for maintainability
 */
const Lumina = (function() {
    'use strict';

    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
        minZoom: 1,
        maxZoom: 5,
        doubleTapDelay: 300,
        doubleTapDistance: 30,
        // Image configuration - replace with actual URLs or base64
        images: {
            base: '',   // Will be loaded dynamically
            north: '',
            south: '',
            east: '',
            west: ''
        }
    };

    // ============================================
    // STATE
    // ============================================
    const state = {
        zoom: 1,
        panX: 0,
        panY: 0,
        isPanning: false,
        lastX: 0,
        lastY: 0,
        initialPinchDistance: 0,
        initialPinchZoom: 1,
        lastTapTime: 0,
        lastTapX: 0,
        lastTapY: 0,
        captureTime: new Date(),
        previousActiveElement: null,
        imagesLoaded: false
    };

    // ============================================
    // DOM REFERENCES
    // ============================================
    let elements = {};

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================
    const utils = {
        sanitizeHTML(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        },

        formatTimestamp(date) {
            return date.toLocaleString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                timeZoneName: 'short'
            });
        },

        safeLocalStorage(action, key, value) {
            try {
                if (action === 'get') return localStorage.getItem(key);
                if (action === 'set') { localStorage.setItem(key, value); return true; }
                if (action === 'remove') { localStorage.removeItem(key); return true; }
            } catch (e) {
                console.error('localStorage error:', e);
                return null;
            }
        },

        vibrate(pattern) {
            if (navigator.vibrate) navigator.vibrate(pattern);
        }
    };

    // ============================================
    // CARD VIEWER MODULE
    // ============================================
    const cardViewer = {
        layers: {},

        init() {
            this.layers = {
                north: document.getElementById('layer-north'),
                south: document.getElementById('layer-south'),
                east: document.getElementById('layer-east'),
                west: document.getElementById('layer-west')
            };
        },

        setZoom(newZoom, centerX = null, centerY = null, animate = false) {
            const oldZoom = state.zoom;
            state.zoom = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, newZoom));
            
            if (centerX !== null && centerY !== null && state.zoom !== oldZoom) {
                const rect = elements.cardWrapper.getBoundingClientRect();
                const relX = (centerX - rect.left) / rect.width - 0.5;
                const relY = (centerY - rect.top) / rect.height - 0.5;
                const zoomDelta = state.zoom - oldZoom;
                state.panX -= relX * zoomDelta * 100;
                state.panY -= relY * zoomDelta * 100;
            }
            
            if (state.zoom === 1) { state.panX = 0; state.panY = 0; }
            this.constrainPan();
            
            if (animate) {
                elements.cardCanvas.classList.add('animating');
                setTimeout(() => elements.cardCanvas.classList.remove('animating'), 150);
            }
            
            this.applyTransform();
            this.updateZoomPill();
        },

        constrainPan() {
            if (state.zoom <= 1) { state.panX = 0; state.panY = 0; return; }
            const maxPan = (state.zoom - 1) * 50;
            state.panX = Math.max(-maxPan, Math.min(maxPan, state.panX));
            state.panY = Math.max(-maxPan, Math.min(maxPan, state.panY));
        },

        applyTransform() {
            elements.cardCanvas.style.transform = `scale(${state.zoom}) translate(${state.panX / state.zoom}%, ${state.panY / state.zoom}%)`;
        },

        updateZoomPill() {
            elements.zoomPill.textContent = `${state.zoom.toFixed(1)}Ã—`;
            elements.zoomPill.classList.toggle('visible', state.zoom > 1);
        },

        updateLight(x, y) {
            const rect = elements.cardWrapper.getBoundingClientRect();
            const px = Math.max(0, Math.min(1, (x - rect.left) / rect.width));
            const py = Math.max(0, Math.min(1, (y - rect.top) / rect.height));

            elements.lightGlow.style.left = x + 'px';
            elements.lightGlow.style.top = y + 'px';
            elements.lightGlow.classList.add('visible');

            const dx = (px - 0.5) * 2;
            const dy = (py - 0.5) * 2;

            this.layers.north.style.opacity = Math.min(1, Math.max(0, -dy) * 1.4);
            this.layers.south.style.opacity = Math.min(1, Math.max(0, dy) * 1.4);
            this.layers.east.style.opacity = Math.min(1, Math.max(0, dx) * 1.4);
            this.layers.west.style.opacity = Math.min(1, Math.max(0, -dx) * 1.4);
        },

        resetLight() {
            elements.lightGlow.classList.remove('visible');
            Object.values(this.layers).forEach(l => l.style.opacity = 0);
        },

        getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        },

        getPinchCenter(touches) {
            return {
                x: (touches[0].clientX + touches[1].clientX) / 2,
                y: (touches[0].clientY + touches[1].clientY) / 2
            };
        },

        loadImages(imageData) {
            // imageData = { base, north, south, east, west }
            const layers = ['base', 'north', 'south', 'east', 'west'];
            let loadedCount = 0;

            layers.forEach(layer => {
                const img = document.getElementById(`layer-${layer}`);
                if (imageData[layer]) {
                    img.onload = () => {
                        loadedCount++;
                        if (loadedCount === layers.length) {
                            document.getElementById('card-placeholder').style.display = 'none';
                            state.imagesLoaded = true;
                            
                            // Set texture layer (uses base image, CSS applies grayscale filter)
                            const textureLayer = document.getElementById('texture-layer');
                            if (textureLayer) {
                                textureLayer.src = imageData.base;
                            }
                        }
                    };
                    img.src = imageData[layer];
                }
            });
        }
    };

    // ============================================
    // DEMO IMAGE GENERATOR (for testing)
    // ============================================
    const demoImages = {
        // Generate a gradient image simulating directional lighting
        generateLayer(direction, width = 400, height = 557) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            // Base card color
            const baseColor = '#2a4a6a';
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, width, height);

            // Add gradient based on direction
            let gradient;
            switch (direction) {
                case 'base':
                    // Neutral ambient - subtle texture
                    gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.1)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.1)');
                    break;
                case 'north':
                    gradient = ctx.createLinearGradient(0, 0, 0, height);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.4)');
                    gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.2)');
                    break;
                case 'south':
                    gradient = ctx.createLinearGradient(0, height, 0, 0);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.4)');
                    gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.2)');
                    break;
                case 'east':
                    gradient = ctx.createLinearGradient(width, 0, 0, 0);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.4)');
                    gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.2)');
                    break;
                case 'west':
                    gradient = ctx.createLinearGradient(0, 0, width, 0);
                    gradient.addColorStop(0, 'rgba(255,255,255,0.4)');
                    gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.2)');
                    break;
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Add card frame
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 8;
            ctx.strokeRect(12, 12, width - 24, height - 24);

            // Add inner frame
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 2;
            ctx.strokeRect(24, 24, width - 48, height - 48);

            // Add "card art" area
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(32, 60, width - 64, height * 0.45);

            // Add highlight in art area based on direction
            if (direction !== 'base') {
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                const artX = 32, artY = 60, artW = width - 64, artH = height * 0.45;
                switch (direction) {
                    case 'north':
                        ctx.fillRect(artX, artY, artW, artH * 0.3);
                        break;
                    case 'south':
                        ctx.fillRect(artX, artY + artH * 0.7, artW, artH * 0.3);
                        break;
                    case 'east':
                        ctx.fillRect(artX + artW * 0.7, artY, artW * 0.3, artH);
                        break;
                    case 'west':
                        ctx.fillRect(artX, artY, artW * 0.3, artH);
                        break;
                }
            }

            // Add title bar
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            ctx.fillRect(32, 20, width - 64, 32);

            // Add text area
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(32, height * 0.58, width - 64, height * 0.32);

            // Demo label
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = 'bold 14px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText('DEMO MODE', width / 2, height - 20);
            ctx.font = '10px system-ui';
            ctx.fillText(`Light: ${direction.toUpperCase()}`, width / 2, height - 6);

            return canvas.toDataURL('image/jpeg', 0.85);
        },

        generateAll() {
            return {
                base: this.generateLayer('base'),
                north: this.generateLayer('north'),
                south: this.generateLayer('south'),
                east: this.generateLayer('east'),
                west: this.generateLayer('west')
            };
        }
    };

    // Try to load images from files, fall back to demo
    function loadImagesWithFallback() {
        // Check if local images exist (try both .jpg and .JPG)
        const testImg = new Image();
        testImg.onload = () => {
            // Local images exist, load them (same directory, uppercase)
            cardViewer.loadImages({
                base: 'base.JPG',
                north: 'north.JPG',
                south: 'south.JPG',
                east: 'east.JPG',
                west: 'west.JPG'
            });
            console.log('Loaded local images (uppercase .JPG)');
        };
        testImg.onerror = () => {
            // Try lowercase extension
            const testImg2 = new Image();
            testImg2.onload = () => {
                cardViewer.loadImages({
                    base: 'base.jpg',
                    north: 'north.jpg',
                    south: 'south.jpg',
                    east: 'east.jpg',
                    west: 'west.jpg'
                });
                console.log('Loaded local images (lowercase .jpg)');
            };
            testImg2.onerror = () => {
                // No local images, use demo mode
                console.log('No local images found, using demo mode');
                const demoData = demoImages.generateAll();
                cardViewer.loadImages(demoData);
            };
            testImg2.src = 'base.jpg';
        };
        testImg.src = 'base.JPG';
    }

    // ============================================
    // TEXTURE SLIDER MODULE
    // ============================================
    const textureSlider = {
        position: 0, // 0-100
        isDragging: false,
        activeContext: 'main', // 'main' or 'fullscreen'

        init() {
            this.setupSlider('main');
        },

        setupSlider(context) {
            const prefix = context === 'fullscreen' ? 'fs-' : '';
            const wrapper = document.getElementById(context === 'fullscreen' ? 'fullscreen-card-wrapper' : 'card-wrapper');
            const slider = document.getElementById(prefix + 'texture-slider');
            
            if (!slider || !wrapper) return;

            // Mouse events
            slider.addEventListener('mousedown', (e) => this.startDrag(e, context));
            
            // Touch events
            slider.addEventListener('touchstart', (e) => this.startDrag(e, context), { passive: false });
            
            // Track click to jump
            const track = document.getElementById(context === 'fullscreen' ? 'fullscreen-controls' : 'texture-slider-track');
            if (track) {
                track.addEventListener('click', (e) => {
                    if (e.target.closest('.texture-track-bar')) {
                        const bar = e.target.closest('.texture-track-bar');
                        const rect = bar.getBoundingClientRect();
                        const pos = ((e.clientX - rect.left) / rect.width) * 100;
                        this.setPosition(Math.max(0, Math.min(100, pos)), context);
                    }
                });
            }
        },

        startDrag(e, context) {
            e.preventDefault();
            this.isDragging = true;
            this.activeContext = context;
            
            const wrapper = document.getElementById(context === 'fullscreen' ? 'fullscreen-card-wrapper' : 'card-wrapper');
            wrapper.classList.add('slider-active');
            
            document.addEventListener('mousemove', this.handleDrag);
            document.addEventListener('mouseup', this.stopDrag);
            document.addEventListener('touchmove', this.handleDrag, { passive: false });
            document.addEventListener('touchend', this.stopDrag);
        },

        handleDrag: (e) => {
            if (!textureSlider.isDragging) return;
            e.preventDefault();
            
            const context = textureSlider.activeContext;
            const wrapper = document.getElementById(context === 'fullscreen' ? 'fullscreen-card-wrapper' : 'card-wrapper');
            const rect = wrapper.getBoundingClientRect();
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const pos = ((clientX - rect.left) / rect.width) * 100;
            
            textureSlider.setPosition(Math.max(0, Math.min(100, pos)), context);
        },

        stopDrag: () => {
            if (!textureSlider.isDragging) return;
            textureSlider.isDragging = false;
            
            const wrapper = document.getElementById(textureSlider.activeContext === 'fullscreen' ? 'fullscreen-card-wrapper' : 'card-wrapper');
            wrapper.classList.remove('slider-active');
            
            document.removeEventListener('mousemove', textureSlider.handleDrag);
            document.removeEventListener('mouseup', textureSlider.stopDrag);
            document.removeEventListener('touchmove', textureSlider.handleDrag);
            document.removeEventListener('touchend', textureSlider.stopDrag);
        },

        setPosition(pos, context = 'main') {
            this.position = pos;
            
            // Update both contexts to stay in sync
            ['main', 'fullscreen'].forEach(ctx => {
                const prefix = ctx === 'fullscreen' ? 'fs-' : '';
                const slider = document.getElementById(prefix + 'texture-slider');
                const texture = document.getElementById(prefix + 'texture-layer');
                const fill = document.getElementById(prefix + 'texture-track-fill');
                const labelColor = document.getElementById(prefix + 'label-color');
                const labelTexture = document.getElementById(prefix + 'label-texture');
                
                if (slider) {
                    slider.style.left = pos + '%';
                    slider.setAttribute('aria-valuenow', Math.round(pos));
                }
                if (texture) {
                    texture.style.clipPath = `inset(0 ${100 - pos}% 0 0)`;
                }
                if (fill) {
                    fill.style.width = pos + '%';
                }
                if (labelColor) {
                    labelColor.classList.toggle('active', pos < 50);
                }
                if (labelTexture) {
                    labelTexture.classList.toggle('active', pos >= 50);
                }
            });
        },

        loadTextureImage(src) {
            document.getElementById('texture-layer').src = src;
            document.getElementById('fs-texture-layer').src = src;
        }
    };

    // ============================================
    // FULLSCREEN MODULE
    // ============================================
    const fullscreen = {
        isActive: false,
        previousFocus: null,
        fsState: {
            zoom: 1,
            panX: 0,
            panY: 0
        },

        init() {
            // Setup fullscreen card interactions
            this.setupCardInteractions();
        },

        enter() {
            this.isActive = true;
            this.previousFocus = document.activeElement;
            
            document.body.classList.add('fullscreen-active');
            document.getElementById('fullscreen-overlay').classList.add('active');
            
            // Copy current images to fullscreen
            ['base', 'north', 'south', 'east', 'west'].forEach(layer => {
                const src = document.getElementById(`layer-${layer}`).src;
                document.getElementById(`fs-layer-${layer}`).src = src;
            });
            
            // Copy texture
            const textureSrc = document.getElementById('texture-layer').src;
            document.getElementById('fs-texture-layer').src = textureSrc;
            
            // Setup slider for fullscreen
            textureSlider.setupSlider('fullscreen');
            
            // Reset fullscreen zoom
            this.fsState = { zoom: 1, panX: 0, panY: 0 };
            this.applyTransform();
            this.updateZoomLevel();
            
            // Focus close button
            document.getElementById('fullscreen-close').focus();
            
            // Try native fullscreen API for true immersion
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(() => {});
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            }
            
            utils.vibrate(10);
        },

        exit() {
            this.isActive = false;
            
            document.body.classList.remove('fullscreen-active');
            document.getElementById('fullscreen-overlay').classList.remove('active');
            
            // Exit native fullscreen
            if (document.exitFullscreen) {
                document.exitFullscreen().catch(() => {});
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
            
            // Restore focus
            if (this.previousFocus) {
                this.previousFocus.focus();
            }
        },

        setupCardInteractions() {
            const wrapper = document.getElementById('fullscreen-card-wrapper');
            const canvas = document.getElementById('fullscreen-card-canvas');
            if (!wrapper || !canvas) return;

            const fsLayers = {
                north: document.getElementById('fs-layer-north'),
                south: document.getElementById('fs-layer-south'),
                east: document.getElementById('fs-layer-east'),
                west: document.getElementById('fs-layer-west')
            };

            let isPanning = false;
            let lastX = 0, lastY = 0;
            let lastTapTime = 0, lastTapX = 0, lastTapY = 0;
            let initialPinchDistance = 0, initialPinchZoom = 1;

            const updateLight = (x, y) => {
                const rect = wrapper.getBoundingClientRect();
                const px = Math.max(0, Math.min(1, (x - rect.left) / rect.width));
                const py = Math.max(0, Math.min(1, (y - rect.top) / rect.height));
                const dx = (px - 0.5) * 2;
                const dy = (py - 0.5) * 2;

                fsLayers.north.style.opacity = Math.min(1, Math.max(0, -dy) * 1.4);
                fsLayers.south.style.opacity = Math.min(1, Math.max(0, dy) * 1.4);
                fsLayers.east.style.opacity = Math.min(1, Math.max(0, dx) * 1.4);
                fsLayers.west.style.opacity = Math.min(1, Math.max(0, -dx) * 1.4);
            };

            const resetLight = () => {
                Object.values(fsLayers).forEach(l => l.style.opacity = 0);
            };

            const getPinchDistance = (touches) => {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            };

            // Touch handlers
            wrapper.addEventListener('touchstart', e => {
                if (textureSlider.isDragging) return;
                
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    const now = Date.now();
                    const dx = touch.clientX - lastTapX;
                    const dy = touch.clientY - lastTapY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (now - lastTapTime < CONFIG.doubleTapDelay && distance < CONFIG.doubleTapDistance) {
                        e.preventDefault();
                        this.setZoom(this.fsState.zoom > 1 ? 1 : 3, touch.clientX, touch.clientY, true);
                        utils.vibrate(10);
                        lastTapTime = 0;
                    } else {
                        lastTapTime = now;
                        lastTapX = touch.clientX;
                        lastTapY = touch.clientY;
                        isPanning = true;
                        lastX = touch.clientX;
                        lastY = touch.clientY;
                        updateLight(lastX, lastY);
                    }
                } else if (e.touches.length === 2) {
                    isPanning = false;
                    initialPinchDistance = getPinchDistance(e.touches);
                    initialPinchZoom = this.fsState.zoom;
                }
            }, { passive: false });

            wrapper.addEventListener('touchmove', e => {
                if (textureSlider.isDragging) return;
                e.preventDefault();
                
                if (e.touches.length === 1 && isPanning) {
                    const t = e.touches[0];
                    updateLight(t.clientX, t.clientY);
                    
                    if (this.fsState.zoom > 1) {
                        const rect = wrapper.getBoundingClientRect();
                        this.fsState.panX += (t.clientX - lastX) / rect.width * 100;
                        this.fsState.panY += (t.clientY - lastY) / rect.height * 100;
                        this.constrainPan();
                        this.applyTransform();
                    }
                    lastX = t.clientX;
                    lastY = t.clientY;
                } else if (e.touches.length === 2) {
                    const currentDistance = getPinchDistance(e.touches);
                    const center = {
                        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                        y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                    };
                    this.setZoom(initialPinchZoom * (currentDistance / initialPinchDistance), center.x, center.y);
                }
            }, { passive: false });

            wrapper.addEventListener('touchend', e => {
                if (e.touches.length === 0) {
                    isPanning = false;
                    resetLight();
                } else if (e.touches.length === 1) {
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    isPanning = true;
                }
            }, { passive: true });

            // Mouse handlers
            let lastClickTime = 0;

            wrapper.addEventListener('mousedown', e => {
                if (textureSlider.isDragging) return;
                const now = Date.now();
                if (now - lastClickTime < CONFIG.doubleTapDelay) {
                    this.setZoom(this.fsState.zoom > 1 ? 1 : 3, e.clientX, e.clientY, true);
                    lastClickTime = 0;
                } else {
                    lastClickTime = now;
                    isPanning = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                }
            });

            wrapper.addEventListener('mousemove', e => {
                if (textureSlider.isDragging) return;
                updateLight(e.clientX, e.clientY);
                if (isPanning && this.fsState.zoom > 1 && e.buttons === 1) {
                    const rect = wrapper.getBoundingClientRect();
                    this.fsState.panX += (e.clientX - lastX) / rect.width * 100;
                    this.fsState.panY += (e.clientY - lastY) / rect.height * 100;
                    this.constrainPan();
                    this.applyTransform();
                    lastX = e.clientX;
                    lastY = e.clientY;
                }
            });

            wrapper.addEventListener('mouseup', () => isPanning = false);
            wrapper.addEventListener('mouseleave', () => { isPanning = false; resetLight(); });

            wrapper.addEventListener('wheel', e => {
                e.preventDefault();
                this.setZoom(this.fsState.zoom + (e.deltaY < 0 ? 0.5 : -0.5), e.clientX, e.clientY);
            }, { passive: false });
        },

        setZoom(newZoom, centerX = null, centerY = null, animate = false) {
            const oldZoom = this.fsState.zoom;
            this.fsState.zoom = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, newZoom));
            
            if (centerX !== null && centerY !== null && this.fsState.zoom !== oldZoom) {
                const wrapper = document.getElementById('fullscreen-card-wrapper');
                const rect = wrapper.getBoundingClientRect();
                const relX = (centerX - rect.left) / rect.width - 0.5;
                const relY = (centerY - rect.top) / rect.height - 0.5;
                const zoomDelta = this.fsState.zoom - oldZoom;
                this.fsState.panX -= relX * zoomDelta * 100;
                this.fsState.panY -= relY * zoomDelta * 100;
            }
            
            if (this.fsState.zoom === 1) {
                this.fsState.panX = 0;
                this.fsState.panY = 0;
            }
            
            this.constrainPan();
            
            const canvas = document.getElementById('fullscreen-card-canvas');
            if (animate) {
                canvas.classList.add('animating');
                setTimeout(() => canvas.classList.remove('animating'), 150);
            }
            
            this.applyTransform();
            this.updateZoomLevel();
        },

        constrainPan() {
            if (this.fsState.zoom <= 1) {
                this.fsState.panX = 0;
                this.fsState.panY = 0;
                return;
            }
            const maxPan = (this.fsState.zoom - 1) * 50;
            this.fsState.panX = Math.max(-maxPan, Math.min(maxPan, this.fsState.panX));
            this.fsState.panY = Math.max(-maxPan, Math.min(maxPan, this.fsState.panY));
        },

        applyTransform() {
            const canvas = document.getElementById('fullscreen-card-canvas');
            canvas.style.transform = `scale(${this.fsState.zoom}) translate(${this.fsState.panX / this.fsState.zoom}%, ${this.fsState.panY / this.fsState.zoom}%)`;
        },

        updateZoomLevel() {
            document.getElementById('fs-zoom-level').textContent = `${this.fsState.zoom.toFixed(1)}Ã—`;
        }
    };

    // ============================================
    // FORM VALIDATION MODULE
    // ============================================
    const validation = {
        urlPatterns: {
            ebay: {
                domains: ['ebay.com', 'ebay.co.uk', 'ebay.ca', 'ebay.com.au', 'ebay.de', 'ebay.fr'],
                pattern: /\/itm\//,
                name: 'eBay',
                example: 'https://www.ebay.com/itm/123456789'
            },
            facebook: {
                domains: ['facebook.com', 'fb.com'],
                pattern: /\/(marketplace|groups)\//,
                name: 'Facebook',
                example: 'https://www.facebook.com/marketplace/item/123'
            },
            tcgplayer: {
                domains: ['tcgplayer.com'],
                pattern: /\/(product|listing)\//,
                name: 'TCGPlayer',
                example: 'https://www.tcgplayer.com/product/123456'
            },
            mercari: {
                domains: ['mercari.com', 'merc.li'],
                pattern: /\/(us\/item|item)\//,
                name: 'Mercari',
                example: 'https://www.mercari.com/us/item/m123/'
            },
            other: {
                domains: null,
                pattern: null,
                name: 'Link',
                example: 'https://example.com/listing'
            }
        },

        validateUrl(url, platform) {
            if (!url || !url.trim()) return { valid: true, empty: true };
            
            url = url.trim();
            const config = this.urlPatterns[platform];
            
            if (!url.match(/^https?:\/\//i)) {
                return { valid: false, error: 'URL must start with https://', example: config.example };
            }
            
            try {
                const urlObj = new URL(url);
                const hostname = urlObj.hostname.replace(/^www\./, '');
                
                if (config.domains) {
                    const domainMatch = config.domains.some(d => hostname === d || hostname.endsWith('.' + d));
                    if (!domainMatch) {
                        return { valid: false, error: `Please use a valid ${config.name} URL`, example: config.example };
                    }
                }
                
                if (config.pattern && !config.pattern.test(url)) {
                    return { valid: false, error: `This doesn't look like a ${config.name} listing URL`, example: config.example };
                }
                
                return { valid: true };
            } catch (e) {
                return { valid: false, error: 'Invalid URL format', example: config.example };
            }
        },

        showInputError(inputId, message) {
            const input = document.getElementById(inputId);
            input.classList.add('error');
            
            const existingError = input.parentElement.querySelector('.input-error');
            if (existingError) existingError.remove();
            
            const errorEl = document.createElement('div');
            errorEl.className = 'input-error';
            errorEl.textContent = message;
            input.parentElement.appendChild(errorEl);
        },

        clearInputError(inputId) {
            const input = document.getElementById(inputId);
            input.classList.remove('error');
            const existingError = input.parentElement.querySelector('.input-error');
            if (existingError) existingError.remove();
        },

        validateAllUrls() {
            let allValid = true;
            ['ebay', 'facebook', 'tcgplayer', 'mercari', 'other'].forEach(platform => {
                const input = document.getElementById('link-' + platform);
                const result = this.validateUrl(input.value, platform);
                if (!result.valid && !result.empty) {
                    allValid = false;
                    this.showInputError('link-' + platform, result.error);
                }
            });
            return allValid;
        },

        setupValidationListeners() {
            ['ebay', 'facebook', 'tcgplayer', 'mercari', 'other'].forEach(platform => {
                const input = document.getElementById('link-' + platform);
                input.addEventListener('blur', () => {
                    const result = this.validateUrl(input.value, platform);
                    if (!result.valid && !result.empty) {
                        this.showInputError('link-' + platform, result.error);
                    } else {
                        this.clearInputError('link-' + platform);
                    }
                });
                input.addEventListener('input', () => this.clearInputError('link-' + platform));
            });
        }
    };

    // ============================================
    // AUTO-DETECTION MODULE
    // ============================================
    const autoDetection = {
        async analyzeCardImage() {
            // Placeholder for OCR + API integration
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({
                        name: "Mewtwo EX",
                        set: "Next Destinies",
                        number: "54/99",
                        language: "EN",
                        edition: "UNL"
                    });
                }, 1200);
            });
        },

        async init() {
            const banner = document.getElementById('auto-detect-banner');
            const spinner = document.getElementById('detect-spinner');

            try {
                const detected = await this.analyzeCardImage();
                
                spinner.style.display = 'none';
                banner.classList.remove('loading');
                banner.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                        <polyline points="22 4 12 14.01 9 11.01"/>
                    </svg>
                    <span>Card details auto-detected from scan</span>
                `;
                
                document.getElementById('card-name').value = detected.name;
                document.getElementById('card-name').placeholder = 'Card name';
                document.getElementById('card-set').value = detected.set;
                document.getElementById('card-set').placeholder = 'Set name';
                document.getElementById('card-number').value = detected.number;
                document.getElementById('card-language').value = detected.language;
                document.getElementById('card-edition').value = detected.edition;
                
            } catch (e) {
                banner.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                        <circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/>
                    </svg>
                    <span style="color: var(--text-secondary)">Could not auto-detect. Please enter manually.</span>
                `;
                document.getElementById('card-name').placeholder = 'Enter card name';
                document.getElementById('card-set').placeholder = 'Enter set name';
            }
        }
    };

    // ============================================
    // MODAL MODULE
    // ============================================
    const modal = {
        open() {
            state.previousActiveElement = document.activeElement;
            elements.modalOverlay.classList.add('visible');
            document.getElementById('modal-cancel').focus();
            document.body.style.overflow = 'hidden';
            utils.vibrate(10);
        },

        close() {
            elements.modalOverlay.classList.remove('visible');
            document.body.style.overflow = '';
            if (state.previousActiveElement) {
                state.previousActiveElement.focus();
            }
        },

        handleConfirm() {
            const data = {
                name: utils.sanitizeHTML(document.getElementById('card-name').value),
                set: utils.sanitizeHTML(document.getElementById('card-set').value),
                number: utils.sanitizeHTML(document.getElementById('card-number').value),
                language: document.getElementById('card-language').value,
                edition: document.getElementById('card-edition').value,
                grade: document.getElementById('card-grade').value,
                notes: utils.sanitizeHTML(document.getElementById('card-notes').value),
                links: {
                    ebay: document.getElementById('link-ebay').value.trim(),
                    facebook: document.getElementById('link-facebook').value.trim(),
                    tcgplayer: document.getElementById('link-tcgplayer').value.trim(),
                    mercari: document.getElementById('link-mercari').value.trim(),
                    other: document.getElementById('link-other').value.trim()
                },
                timestamp: utils.formatTimestamp(state.captureTime),
                lockedAt: new Date().toISOString()
            };
            
            const saved = utils.safeLocalStorage('set', 'lumina-card-data', JSON.stringify(data));
            if (saved) {
                utils.vibrate(20);
                window.location.href = 'lumina-locked.html';
            } else {
                alert('Unable to save. Please check your browser settings and try again.');
                modal.close();
            }
        }
    };

    // ============================================
    // EVENT HANDLERS
    // ============================================
    function setupEventListeners() {
        // Touch handlers
        elements.cardWrapper.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const now = Date.now();
                const dx = touch.clientX - state.lastTapX;
                const dy = touch.clientY - state.lastTapY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (now - state.lastTapTime < CONFIG.doubleTapDelay && distance < CONFIG.doubleTapDistance) {
                    e.preventDefault();
                    const newZoom = state.zoom > 1 ? 1 : 3;
                    cardViewer.setZoom(newZoom, touch.clientX, touch.clientY, true);
                    utils.vibrate(10);
                    state.lastTapTime = 0;
                } else {
                    state.lastTapTime = now;
                    state.lastTapX = touch.clientX;
                    state.lastTapY = touch.clientY;
                    state.isPanning = true;
                    state.lastX = touch.clientX;
                    state.lastY = touch.clientY;
                    cardViewer.updateLight(state.lastX, state.lastY);
                }
            } else if (e.touches.length === 2) {
                state.isPanning = false;
                state.initialPinchDistance = cardViewer.getPinchDistance(e.touches);
                state.initialPinchZoom = state.zoom;
            }
        }, { passive: false });

        elements.cardWrapper.addEventListener('touchmove', e => {
            e.preventDefault();
            
            if (e.touches.length === 1 && state.isPanning) {
                const t = e.touches[0];
                cardViewer.updateLight(t.clientX, t.clientY);
                
                if (state.zoom > 1) {
                    const rect = elements.cardWrapper.getBoundingClientRect();
                    state.panX += (t.clientX - state.lastX) / rect.width * 100;
                    state.panY += (t.clientY - state.lastY) / rect.height * 100;
                    cardViewer.constrainPan();
                    cardViewer.applyTransform();
                }
                state.lastX = t.clientX;
                state.lastY = t.clientY;
                
            } else if (e.touches.length === 2) {
                const currentDistance = cardViewer.getPinchDistance(e.touches);
                const center = cardViewer.getPinchCenter(e.touches);
                const scale = currentDistance / state.initialPinchDistance;
                cardViewer.setZoom(state.initialPinchZoom * scale, center.x, center.y);
            }
        }, { passive: false });

        elements.cardWrapper.addEventListener('touchend', e => {
            if (e.touches.length === 0) {
                state.isPanning = false;
                cardViewer.resetLight();
            } else if (e.touches.length === 1) {
                state.lastX = e.touches[0].clientX;
                state.lastY = e.touches[0].clientY;
                state.isPanning = true;
            }
        }, { passive: true });

        // Mouse handlers
        let lastClickTime = 0;

        elements.cardWrapper.addEventListener('mousedown', e => {
            const now = Date.now();
            if (now - lastClickTime < CONFIG.doubleTapDelay) {
                const newZoom = state.zoom > 1 ? 1 : 3;
                cardViewer.setZoom(newZoom, e.clientX, e.clientY, true);
                lastClickTime = 0;
            } else {
                lastClickTime = now;
                state.isPanning = true;
                state.lastX = e.clientX;
                state.lastY = e.clientY;
            }
        });

        elements.cardWrapper.addEventListener('mousemove', e => {
            cardViewer.updateLight(e.clientX, e.clientY);
            if (state.isPanning && state.zoom > 1 && e.buttons === 1) {
                const rect = elements.cardWrapper.getBoundingClientRect();
                state.panX += (e.clientX - state.lastX) / rect.width * 100;
                state.panY += (e.clientY - state.lastY) / rect.height * 100;
                cardViewer.constrainPan();
                cardViewer.applyTransform();
                state.lastX = e.clientX;
                state.lastY = e.clientY;
            }
        });

        elements.cardWrapper.addEventListener('mouseup', () => state.isPanning = false);
        elements.cardWrapper.addEventListener('mouseleave', () => {
            state.isPanning = false;
            cardViewer.resetLight();
        });

        elements.cardWrapper.addEventListener('wheel', e => {
            e.preventDefault();
            cardViewer.setZoom(state.zoom + (e.deltaY < 0 ? 0.5 : -0.5), e.clientX, e.clientY);
        }, { passive: false });

        // Zoom buttons
        document.getElementById('zoom-in-btn').addEventListener('click', () => {
            cardViewer.setZoom(state.zoom + 0.5, null, null, true);
            utils.vibrate(5);
        });
        
        document.getElementById('zoom-out-btn').addEventListener('click', () => {
            cardViewer.setZoom(state.zoom - 0.5, null, null, true);
            utils.vibrate(5);
        });

        // Generate proof button
        document.getElementById('generate-proof-btn').addEventListener('click', () => {
            if (!validation.validateAllUrls()) {
                document.getElementById('section-links').classList.remove('collapsed');
                document.getElementById('section-links').scrollIntoView({ behavior: 'smooth', block: 'center' });
                utils.vibrate([50, 50, 50]);
                return;
            }
            modal.open();
        });

        // Modal buttons
        document.getElementById('modal-cancel').addEventListener('click', modal.close);
        document.getElementById('modal-confirm').addEventListener('click', modal.handleConfirm);

        elements.modalOverlay.addEventListener('click', e => {
            if (e.target === elements.modalOverlay) modal.close();
        });

        // Keyboard handling for modal
        document.addEventListener('keydown', e => {
            if (!elements.modalOverlay.classList.contains('visible')) return;
            
            if (e.key === 'Escape') {
                modal.close();
            } else if (e.key === 'Tab') {
                const focusable = elements.modalOverlay.querySelectorAll('button');
                const first = focusable[0];
                const last = focusable[focusable.length - 1];
                
                if (e.shiftKey && document.activeElement === first) {
                    e.preventDefault();
                    last.focus();
                } else if (!e.shiftKey && document.activeElement === last) {
                    e.preventDefault();
                    first.focus();
                }
            }
        });

        // Back button
        document.getElementById('back-btn').addEventListener('click', () => {
            window.history.back();
        });
    }

    // ============================================
    // PUBLIC API
    // ============================================
    function toggleSection(id) {
        const section = document.getElementById(id);
        const header = section.querySelector('.section-header');
        const isCollapsed = section.classList.toggle('collapsed');
        header.setAttribute('aria-expanded', !isCollapsed);
        
        if (!isCollapsed) {
            section.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }

    function handleSectionKeydown(event, id) {
        if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            toggleSection(id);
        }
    }

    function init() {
        // Cache DOM references
        elements = {
            cardWrapper: document.getElementById('card-wrapper'),
            cardCanvas: document.getElementById('card-canvas'),
            lightGlow: document.getElementById('light-glow'),
            zoomPill: document.getElementById('zoom-pill'),
            modalOverlay: document.getElementById('modal-overlay')
        };

        // Initialize modules
        cardViewer.init();
        textureSlider.init();
        fullscreen.init();
        validation.setupValidationListeners();
        
        // Set capture time
        document.getElementById('capture-time').textContent = utils.formatTimestamp(state.captureTime);
        
        // Setup events
        setupEventListeners();
        setupFullscreenEvents();
        
        // Start auto-detection
        autoDetection.init();

        // Load images - checks for local files first, falls back to generated demo
        loadImagesWithFallback();

        // Global error handling
        window.addEventListener('error', e => console.error('Global error:', e.error));
        window.addEventListener('unhandledrejection', e => console.error('Unhandled rejection:', e.reason));
    }

    function setupFullscreenEvents() {
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const fullscreenClose = document.getElementById('fullscreen-close');
        const fullscreenCardArea = document.getElementById('fullscreen-card-area');
        const fsZoomIn = document.getElementById('fs-zoom-in');
        const fsZoomOut = document.getElementById('fs-zoom-out');
        
        // Enter fullscreen
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', () => {
                fullscreen.enter();
            });
        }
        
        // Exit fullscreen
        if (fullscreenClose) {
            fullscreenClose.addEventListener('click', () => {
                fullscreen.exit();
            });
        }
        
        // Escape key exits fullscreen
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape' && fullscreen.isActive) {
                fullscreen.exit();
            }
        });
        
        // Click outside card area exits fullscreen
        if (fullscreenCardArea) {
            fullscreenCardArea.addEventListener('click', e => {
                if (e.target.id === 'fullscreen-card-area') {
                    fullscreen.exit();
                }
            });
        }
        
        // Fullscreen zoom buttons
        if (fsZoomIn) {
            fsZoomIn.addEventListener('click', () => {
                fullscreen.setZoom(fullscreen.fsState.zoom + 0.5, null, null, true);
                utils.vibrate(5);
            });
        }
        
        if (fsZoomOut) {
            fsZoomOut.addEventListener('click', () => {
                fullscreen.setZoom(fullscreen.fsState.zoom - 0.5, null, null, true);
                utils.vibrate(5);
            });
        }
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    // Return public API
    return {
        toggleSection,
        handleSectionKeydown,
        loadImages: cardViewer.loadImages.bind(cardViewer),
        generateDemoImages: demoImages.generateAll.bind(demoImages),
        getState: () => ({ ...state }),
        utils
    };
})();
    </script>
</body>
</html>
